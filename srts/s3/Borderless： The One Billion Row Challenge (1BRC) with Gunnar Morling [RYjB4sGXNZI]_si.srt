1
00:00:00,000 --> 00:00:13,920
So, the timer is on.

2
00:00:13,920 --> 00:00:22,240
We can start this episode of Ogródie in our sub-section or our special section of our

3
00:00:22,240 --> 00:00:29,680
show dedicated to English-speaking guests and English-speaking audiences.

4
00:00:29,680 --> 00:00:36,119
This branch of our episode is designed so that we can get the best experts in the field

5
00:00:36,119 --> 00:00:40,000
and they still can be shared among our audience.

6
00:00:40,000 --> 00:00:42,759
So, welcome to our episode.

7
00:00:42,759 --> 00:00:52,560
Today, we have a very special guest with us, Mr. Gunnar Mörling and my host, András Brodnik

8
00:00:52,560 --> 00:00:55,400
and myself, Otto.

9
00:00:55,400 --> 00:01:00,799
Today, we are attending a Make-It conference in Portoro, Slovenia.

10
00:01:00,799 --> 00:01:05,879
So this is a coastline of Slovenia that you might see behind us.

11
00:01:05,879 --> 00:01:09,080
But sadly not listened to.

12
00:01:09,080 --> 00:01:19,360
And yeah, when we were deciding the agenda for the Make-It conference, we really wanted

13
00:01:19,360 --> 00:01:26,760
to have you in this conference as well, because in a while, there was this excitement in Java

14
00:01:26,760 --> 00:01:32,480
world where people were trying to solve this really interesting challenge that you designed

15
00:01:32,480 --> 00:01:36,720
and people have gone crazy about it.

16
00:01:36,720 --> 00:01:37,720
Absolutely, yes.

17
00:01:37,720 --> 00:01:42,040
I managed to meet a few of these crazy people that actually solved your challenge and I

18
00:01:42,040 --> 00:01:43,360
hope that we'll talk about it.

19
00:01:43,360 --> 00:01:44,360
Yes, absolutely.

20
00:01:44,360 --> 00:01:48,800
So, welcome to the show and if you can introduce yourself to the audience, that would be great.

21
00:01:49,239 --> 00:01:50,239
Yes, of course.

22
00:01:50,239 --> 00:01:51,239
So, thank you so much for having me.

23
00:01:51,239 --> 00:01:52,760
Really excited to be here.

24
00:01:52,760 --> 00:01:55,680
Really excited to be at the conference.

25
00:01:55,680 --> 00:02:00,160
And yes, my name is Gunnar Mörling, I work as a software engineer at a company called

26
00:02:00,160 --> 00:02:01,160
Decodable.

27
00:02:01,160 --> 00:02:05,040
We built a managed platform for stream processing there.

28
00:02:05,040 --> 00:02:09,520
And yes, this challenge, the One Billion Road Challenge, actually was like a side thing,

29
00:02:09,520 --> 00:02:14,960
which I started, you know, after Christmas and it ran for January, it really took off.

30
00:02:14,960 --> 00:02:18,279
Thankfully, Decodable also sponsored it in the end.

31
00:02:18,279 --> 00:02:20,559
But yeah, so that's the story.

32
00:02:20,559 --> 00:02:21,559
Sweet.

33
00:02:21,559 --> 00:02:23,160
Sweet and short.

34
00:02:23,160 --> 00:02:29,440
I would like you to tell us, like, what is the definition, what's the challenge about?

35
00:02:29,440 --> 00:02:30,440
Right.

36
00:02:30,440 --> 00:02:31,440
Let's start, let's go directly to it.

37
00:02:31,440 --> 00:02:32,440
Absolutely.

38
00:02:32,440 --> 00:02:33,440
What's it all about?

39
00:02:33,440 --> 00:02:34,440
Right.

40
00:02:34,440 --> 00:02:35,440
Yeah, I mean, it's pretty much in the name already, right?

41
00:02:35,440 --> 00:02:42,600
So, it was a challenge and the task was to process a file which has one billion rows

42
00:02:42,600 --> 00:02:44,160
of temperature measurements.

43
00:02:44,600 --> 00:02:50,199
So it's essentially like a simple CSV file, well, not quite because the delimiter is not

44
00:02:50,199 --> 00:02:54,759
a semicolon, not a comma, but it's a semicolon, but it's like a CSV file.

45
00:02:54,759 --> 00:02:57,839
And there's essentially rows of temperature measurements.

46
00:02:57,839 --> 00:03:04,320
There's a station name like Hamburg or Portorosch, and then a values associated to that.

47
00:03:04,320 --> 00:03:06,119
And the task was very simple.

48
00:03:06,119 --> 00:03:11,720
You needed to calculate the min value, the max value and the average value per station.

49
00:03:11,720 --> 00:03:16,199
And the only caveat was, well, as the challenge name says, it's like one billion rows, which

50
00:03:16,199 --> 00:03:21,160
means with this file, a bit depending on the names and how long they are, it was about

51
00:03:21,160 --> 00:03:25,839
like 13 gigabytes of size and you had to process that file as fast as possible.

52
00:03:25,839 --> 00:03:31,000
So very simple task, I would say, very simple to explain and still people spend like one

53
00:03:31,000 --> 00:03:35,960
month and I guess hadn't we, you know, cut it off on January 21st, people would still

54
00:03:35,960 --> 00:03:38,119
be working on it probably.

55
00:03:38,119 --> 00:03:40,440
I like that there was a deadline to it.

56
00:03:40,440 --> 00:03:41,440
Yes.

57
00:03:42,160 --> 00:03:43,160
It doesn't happen anymore.

58
00:03:43,160 --> 00:03:44,160
Yeah.

59
00:03:44,160 --> 00:03:45,160
You just had to put an end to the madness.

60
00:03:45,160 --> 00:03:51,279
We'll go deeper, but just like for people that listen to this, try it out.

61
00:03:51,279 --> 00:03:55,880
It's still a really lovely challenge, although you cannot submit your solution at the moment,

62
00:03:55,880 --> 00:03:56,880
you still can challenge yourself.

63
00:03:56,880 --> 00:03:57,880
Absolutely.

64
00:03:57,880 --> 00:03:58,880
Right.

65
00:03:58,880 --> 00:03:59,880
And you can go there.

66
00:03:59,880 --> 00:04:02,679
I mean, all the implementations are there, so you can check them out.

67
00:04:02,679 --> 00:04:06,440
But I also would recommend people, you know, try it out first by yourself without looking

68
00:04:06,440 --> 00:04:10,360
at what others did, you know, to get some ideas, then of course take inspiration.

69
00:04:10,360 --> 00:04:14,559
But this was part also of the challenge to, you know, so people shouldn't work on it like

70
00:04:14,559 --> 00:04:19,760
secretly and not see what others do, but they could take inspiration and be inspired and

71
00:04:19,760 --> 00:04:22,000
learn from what others did.

72
00:04:22,000 --> 00:04:23,000
Yeah.

73
00:04:23,000 --> 00:04:28,920
I meet a lot of people in December where there's this Advent of Code challenge, right?

74
00:04:28,920 --> 00:04:34,880
And yeah, it's Christmas themed, but look, you don't need to grind every day for the

75
00:04:34,880 --> 00:04:40,079
new to solve all the stars to all the challenges, but you can learn also through the year.

76
00:04:40,799 --> 00:04:44,040
The challenge is given, just explore what other people do.

77
00:04:44,040 --> 00:04:46,279
And I think that's a really important point.

78
00:04:46,279 --> 00:04:51,200
It's not like, yeah, if you don't have children or a lot of free time, then yeah, you can

79
00:04:51,200 --> 00:04:55,799
do it in a specific time frame, but like you can learn your whole life, right?

80
00:04:55,799 --> 00:04:56,799
Yes.

81
00:04:56,799 --> 00:05:01,200
And I mean, I was thinking to do it during Advent of Code, but I decided against it because

82
00:05:01,200 --> 00:05:02,200
I felt...

83
00:05:02,200 --> 00:05:03,200
That would be too much for people.

84
00:05:03,200 --> 00:05:05,320
It would be too much, exactly.

85
00:05:05,320 --> 00:05:06,760
And also it would just be nice.

86
00:05:06,760 --> 00:05:12,119
I mean, January is a bit slow and maybe people are looking for something interesting to do.

87
00:05:12,119 --> 00:05:16,799
And also, you know, I just had some time myself after Christmas to define the challenge and

88
00:05:16,799 --> 00:05:20,959
that's why I said, okay, let's do it during January and see what people do with it.

89
00:05:20,959 --> 00:05:24,559
I want to go now talk a bit about rules, right?

90
00:05:24,559 --> 00:05:30,399
You wrote these rules and first rule, and there might be more, I think I wrote out three

91
00:05:30,399 --> 00:05:35,119
of them, but there might be a few like technical details.

92
00:05:35,119 --> 00:05:36,799
First one is no external libraries.

93
00:05:36,799 --> 00:05:37,799
Yes, exactly.

94
00:05:37,799 --> 00:05:38,799
Why is that?

95
00:05:38,799 --> 00:05:40,720
Mostly, well, for two reasons really.

96
00:05:40,720 --> 00:05:45,920
So one of, I mean, the goal of that was, well, to, you know, provide people and also myself,

97
00:05:45,920 --> 00:05:53,119
frankly speaking with the means to learn something new and find out about new APIs in Java, you

98
00:05:53,119 --> 00:05:59,000
know, the new possibilities like foreign memory and foreign function API, vector API.

99
00:05:59,000 --> 00:06:00,000
So learn about those things.

100
00:06:00,000 --> 00:06:04,320
And if you were just to use an external library, I mean, there would not be that much learning.

101
00:06:04,519 --> 00:06:08,760
I mean, you would learn about that library maybe, but I think, you know, it makes more

102
00:06:08,760 --> 00:06:12,799
sense to do it yourself and like really dig into that and like finding out about all the

103
00:06:12,799 --> 00:06:13,799
possible optimizations.

104
00:06:13,799 --> 00:06:15,440
So that was the one reason.

105
00:06:15,440 --> 00:06:19,600
And then the other reason, well, just for me, I wanted to, you know, keep things manageable

106
00:06:19,600 --> 00:06:21,079
in terms of evaluating this.

107
00:06:21,079 --> 00:06:25,480
And so I felt, okay, if it's just like a thing, so this was another precondition, a single

108
00:06:25,480 --> 00:06:26,480
source file.

109
00:06:26,480 --> 00:06:27,480
So I can look at it.

110
00:06:27,480 --> 00:06:31,519
The entire code is there, you know, so nobody is running their Bitcoin miner in the library

111
00:06:31,519 --> 00:06:32,519
on my environment.

112
00:06:32,720 --> 00:06:34,720
So this also was a reason to do that.

113
00:06:34,720 --> 00:06:41,839
And one rule perhaps that kind of like stands out, I guess a bit is this, it needs to be

114
00:06:41,839 --> 00:06:43,160
done in application time.

115
00:06:43,160 --> 00:06:47,119
So nothing extreme in compilation time or anything like that.

116
00:06:47,119 --> 00:06:50,079
So everything needs to happen in runtime and runtime only.

117
00:06:50,079 --> 00:06:51,079
Right?

118
00:06:51,079 --> 00:06:52,079
Yes.

119
00:06:52,079 --> 00:06:53,079
Right.

120
00:06:53,079 --> 00:06:55,480
So, and this was there because, I mean, how would you draw the line otherwise, right?

121
00:06:55,480 --> 00:07:03,200
Because let's say, then I could just go solve the task once, store the result in a file,

122
00:07:03,200 --> 00:07:07,279
and then my actual measured run would just load that file and like print out the numbers

123
00:07:07,279 --> 00:07:08,279
from that.

124
00:07:08,279 --> 00:07:09,279
That would be kind of pointless.

125
00:07:09,279 --> 00:07:10,279
Right?

126
00:07:10,279 --> 00:07:11,720
That's why I said, like, you cannot keep state.

127
00:07:11,720 --> 00:07:14,399
It needs all to happen at runtime.

128
00:07:14,399 --> 00:07:15,839
And that's what it was.

129
00:07:15,839 --> 00:07:20,359
And we're still talking a bit about rules.

130
00:07:20,359 --> 00:07:27,679
You can get the sample data, you can generate the sample data, but in the like test runs

131
00:07:27,679 --> 00:07:32,200
or benchmarking runs that you actually do, do they run on the same sample data or how

132
00:07:32,200 --> 00:07:34,079
does the sampling of the data works?

133
00:07:34,079 --> 00:07:35,079
Right.

134
00:07:35,079 --> 00:07:38,399
So this is actually a very interesting question because people did something which I did not

135
00:07:38,399 --> 00:07:42,279
expect, which just goes to show my own naivete when it comes to that.

136
00:07:42,279 --> 00:07:47,160
But so yes, I had this data generator and this was there for practical reasons because

137
00:07:47,160 --> 00:07:50,359
I felt I cannot distribute a 30 gigabytes file.

138
00:07:50,359 --> 00:07:54,239
I mean, I guess I could have done a bit more or whatever, but so I thought, okay, people

139
00:07:54,239 --> 00:07:58,880
should just generate themselves and then I don't have this distribution problem.

140
00:07:58,880 --> 00:08:03,760
Now the challenge was that this used a very specific key set.

141
00:08:03,760 --> 00:08:11,200
So I went to Wikipedia, I dug out like 400 something different weather station names

142
00:08:11,200 --> 00:08:15,959
and like the average temperature, which actually exists at this location.

143
00:08:15,959 --> 00:08:20,679
And then the generator would create like a normal distribution of random values.

144
00:08:20,679 --> 00:08:23,799
So you did actually put more effort into making it realistic.

145
00:08:23,799 --> 00:08:24,799
Exactly.

146
00:08:24,799 --> 00:08:27,119
So it's somewhat realistic.

147
00:08:27,119 --> 00:08:31,200
And now people optimize a lot for that specific key set.

148
00:08:31,200 --> 00:08:35,479
So they, and I assumed, okay, those are just examples.

149
00:08:35,479 --> 00:08:40,359
You shouldn't like make any assumptions about these station names, but people optimized

150
00:08:40,359 --> 00:08:45,919
a lot by choosing specific hash functions, which are collision free for those 430 names.

151
00:08:45,919 --> 00:08:47,679
And this kind of stuff.

152
00:08:47,679 --> 00:08:52,479
So which is then in the end, we had like another evaluation where we actually ran against like

153
00:08:52,479 --> 00:08:56,000
10K different stations, also like longer names and so on.

154
00:08:56,000 --> 00:08:59,599
And then actually the leaderboard also was a bit looking different between those guys

155
00:08:59,599 --> 00:09:05,359
who, you know, very much optimized for the specific key set versus those guys who tried

156
00:09:05,359 --> 00:09:08,520
to solve it in a generic way as good as possible.

157
00:09:08,520 --> 00:09:12,359
And then there are a bit, okay, these are like rules, but then there you have like,

158
00:09:12,359 --> 00:09:14,340
you have like few hints in there.

159
00:09:14,340 --> 00:09:18,619
So it's UTF-8 and there's only 10,000 cities.

160
00:09:18,619 --> 00:09:19,619
Yes.

161
00:09:19,619 --> 00:09:20,619
Right.

162
00:09:20,619 --> 00:09:22,299
So you, so there are like, right.

163
00:09:22,299 --> 00:09:23,940
And people ask for that.

164
00:09:23,940 --> 00:09:26,739
So to be honest, this didn't exist initially.

165
00:09:26,739 --> 00:09:29,979
I wasn't really thinking that much, but then people asked me, yes.

166
00:09:29,979 --> 00:09:31,260
How many stations can there be?

167
00:09:31,260 --> 00:09:35,299
Because they wanted to know how large the table is, table B and stuff like that.

168
00:09:35,299 --> 00:09:37,099
How long can those names be?

169
00:09:37,099 --> 00:09:41,859
Um, what's, you know, very specific questions around like encoding and so on.

170
00:09:41,859 --> 00:09:47,260
And then I tried to, you know, put some rules into place and the challenge then was of course

171
00:09:47,260 --> 00:09:51,059
people had already submitted entries at this point.

172
00:09:51,059 --> 00:09:56,340
And so I also didn't want to create a frustration for those who already had entered, you know,

173
00:09:56,340 --> 00:09:57,979
like by invalidating them.

174
00:09:57,979 --> 00:09:59,739
So it was a bit of a balance to yes.

175
00:09:59,739 --> 00:10:00,739
Okay.

176
00:10:00,739 --> 00:10:06,340
We want to make it more specific without invalidating existing entries too much.

177
00:10:06,340 --> 00:10:07,859
I mean, there was a little bit of that.

178
00:10:07,859 --> 00:10:08,859
Yeah.

179
00:10:08,859 --> 00:10:09,859
Yeah.

180
00:10:09,859 --> 00:10:15,059
It was a bit like, you know, building out the plane while you already offline.

181
00:10:15,059 --> 00:10:16,059
Yeah.

182
00:10:16,059 --> 00:10:18,900
Common problems when inventing a new sport.

183
00:10:18,900 --> 00:10:22,539
What about, um, uh, AO?

184
00:10:22,539 --> 00:10:25,900
So the, the, the disc performance and stuff like that.

185
00:10:25,900 --> 00:10:26,900
Yes.

186
00:10:26,900 --> 00:10:27,900
So IO, right.

187
00:10:27,900 --> 00:10:28,900
So yes.

188
00:10:28,900 --> 00:10:29,900
Um, yes.

189
00:10:29,900 --> 00:10:33,140
So this is a very purposefully not a part of the challenge.

190
00:10:33,140 --> 00:10:38,659
So the way it is designed is so initially I said, okay, I want to do like five runs of

191
00:10:39,460 --> 00:10:43,539
each entry and I will, uh, discard the slowest and the fastest run.

192
00:10:43,539 --> 00:10:47,820
And I will then, you know, from the remaining three runs, the meantime, that's, that's the

193
00:10:47,820 --> 00:10:49,179
measured time.

194
00:10:49,179 --> 00:10:54,460
And the idea is that the slowest run would load the file into the page cache of the machine.

195
00:10:54,460 --> 00:10:58,979
Um, and from there it's always served from REM so that IO isn't part of the equation.

196
00:10:58,979 --> 00:11:04,580
And later on, I actually made even more explicit and I just retrieved the file from REM disc.

197
00:11:04,580 --> 00:11:06,780
So it's always guaranteed to come from memory.

198
00:11:06,780 --> 00:11:10,340
The reason being, I just felt, okay, IO is harder to measure.

199
00:11:10,340 --> 00:11:15,140
And, um, I also wanted to be, this is a CPU bound problem and people should spend their

200
00:11:15,140 --> 00:11:19,179
time to, you know, CPU optimize and not the IO path.

201
00:11:19,179 --> 00:11:22,580
But maybe there could be a challenge also geared towards that.

202
00:11:22,580 --> 00:11:24,659
But then I think it's also a bit more complex to run.

203
00:11:24,659 --> 00:11:26,859
Um, so that's why I decided against it this time.

204
00:11:26,859 --> 00:11:30,539
Um, yeah, probably there is a problem with controlling the environment.

205
00:11:30,539 --> 00:11:33,380
Did you have, have you had any like problems with that?

206
00:11:33,380 --> 00:11:34,380
Yes.

207
00:11:34,380 --> 00:11:35,380
Funny you should ask.

208
00:11:35,380 --> 00:11:36,539
I certainly did.

209
00:11:37,299 --> 00:11:43,179
So what happened is I, you know, I was trying to be cheap because I paid initially for it

210
00:11:43,179 --> 00:11:44,179
out of my own pocket.

211
00:11:44,179 --> 00:11:48,700
So what I ended up doing is I got a virtual environment on Hetzner cloud.

212
00:11:48,700 --> 00:11:53,619
It's a German cloud provider, like really, you know, fairly priced.

213
00:11:53,619 --> 00:11:56,659
And I thought, okay, I want to have exclusive CPU calls, right?

214
00:11:56,659 --> 00:11:59,739
I don't want to have like noise neighbor issues and like competing workloads.

215
00:11:59,739 --> 00:12:04,820
So let me do a dedicated CPU course, but then I should be fine with this virtual environment.

216
00:12:04,859 --> 00:12:10,580
So I thought, um, because what happened is at some point, um, I woke up the next day,

217
00:12:10,580 --> 00:12:15,340
like, you know, 40 more PRs or whatever, waiting for review.

218
00:12:15,340 --> 00:12:19,059
And I ran the evaluation scripts and like, I realized, oh, all those times are off.

219
00:12:19,059 --> 00:12:21,700
Like everything is like suddenly twice as fast as before.

220
00:12:21,700 --> 00:12:25,619
So I ran like an existing entry and it wasn't running in half of the time.

221
00:12:25,619 --> 00:12:29,380
And I was going, well, what's, what's going on, um, what's happening here.

222
00:12:29,380 --> 00:12:32,700
And actually I filed even a support ticket with them and, and yeah, they told me.

223
00:12:32,700 --> 00:12:36,140
So they moved this workload to a different host.

224
00:12:36,140 --> 00:12:42,099
So even with my dedicated course, they were just better course, like from one day to another.

225
00:12:42,099 --> 00:12:45,780
And then all my measurements were off and I had to redo it.

226
00:12:45,780 --> 00:12:49,340
And at that point, well, I decided, okay, I need to get like a dedicated box, which,

227
00:12:49,340 --> 00:12:53,320
you know, I really manage or which I can manage together with the community.

228
00:12:53,320 --> 00:12:56,059
So nothing can happen to that.

229
00:12:56,059 --> 00:12:57,059
So that's what we did.

230
00:12:57,059 --> 00:12:59,979
And of course it was a bit of a challenge to a just get it.

231
00:12:59,979 --> 00:13:00,979
It's more expensive.

232
00:13:00,979 --> 00:13:03,940
Of course, thankfully Decodable helped to sponsor it.

233
00:13:03,940 --> 00:13:07,539
And then also I just needed to get help with managing it because for instance, I wanted

234
00:13:07,539 --> 00:13:09,419
to turn off the turbo boost.

235
00:13:09,419 --> 00:13:13,700
I wanted to disable hyper-threading to, you know, make it more comparable.

236
00:13:13,700 --> 00:13:16,780
And people from the community came and helped with it.

237
00:13:16,780 --> 00:13:20,979
So at some point I asked on Twitter, so hey, can, is there anybody who can help me with

238
00:13:20,979 --> 00:13:21,979
it?

239
00:13:21,979 --> 00:13:26,559
And Rene, who I didn't know before he reached out and he said, yeah, I can help you.

240
00:13:26,559 --> 00:13:32,400
So we made a phone call and we, you know, I told about the things I needed to get done

241
00:13:32,400 --> 00:13:34,359
and he was saying, yeah, I can do all that.

242
00:13:34,359 --> 00:13:36,880
And so he sent me his SSH key.

243
00:13:36,880 --> 00:13:41,200
I uploaded his SSH key to the environment we had never before, never met before.

244
00:13:41,200 --> 00:13:45,280
So I gave him the key to the kingdom and you know, he just did the right thing.

245
00:13:45,280 --> 00:13:49,440
And it was just great to see how it can work with the community.

246
00:13:49,440 --> 00:13:52,719
Can you tell us a bit more about how you evaluate these things?

247
00:13:52,719 --> 00:13:58,840
Do you run them like sequentially, daily, like, yeah.

248
00:13:58,840 --> 00:14:04,239
So what happened is I ran them when a new entry came in or when an entry was updated.

249
00:14:04,239 --> 00:14:06,719
So it would do a GitHub pull request.

250
00:14:06,719 --> 00:14:15,359
And at this point in time I would create the, I would run this entry and I had some shell

251
00:14:15,359 --> 00:14:20,280
scripting for that, you know, which made sure like that the environment is configured correctly,

252
00:14:20,280 --> 00:14:26,119
which made sure like the correct number of CPU cores is used, which ran the test suite,

253
00:14:26,119 --> 00:14:27,280
which we had at some point.

254
00:14:27,280 --> 00:14:32,520
So it was like invoking a single shell script, which again, folks from the community built

255
00:14:32,520 --> 00:14:34,400
to make this as easy as possible.

256
00:14:34,400 --> 00:14:38,559
Are you using any kind of like benchmarking tools or is just like start time, end time?

257
00:14:38,559 --> 00:14:40,359
No, there was a benchmark tool.

258
00:14:40,359 --> 00:14:42,640
Now I'm blanking on the name.

259
00:14:42,640 --> 00:14:43,799
I really should know.

260
00:14:43,799 --> 00:14:45,880
But it's like a Java specific.

261
00:14:45,880 --> 00:14:54,440
No, a generic Linux tool for just like running, you know, process a couple of times and then,

262
00:14:54,440 --> 00:14:58,599
you know, calculating like the average value and stuff.

263
00:14:58,599 --> 00:14:59,599
Okay.

264
00:14:59,599 --> 00:15:07,559
I got some technical hints, but I'm not sure what he wants to tell me.

265
00:15:07,559 --> 00:15:10,679
When you are...

266
00:15:10,679 --> 00:15:15,719
I think he's like, can you please not touch microphone like you are doing it right now?

267
00:15:15,719 --> 00:15:16,719
Don't do that.

268
00:15:16,719 --> 00:15:19,840
The problem is it's sliding slightly.

269
00:15:19,840 --> 00:15:21,440
Okay.

270
00:15:21,440 --> 00:15:27,280
I would like to move like from benchmarking perspective.

271
00:15:27,280 --> 00:15:36,479
Like if you should like re-evaluate all the solutions or only by submissions, like if

272
00:15:36,479 --> 00:15:41,919
you change the underlying system that runs it, like is there a time when you rerun all

273
00:15:41,919 --> 00:15:42,919
of them?

274
00:15:42,919 --> 00:15:45,599
Like do you do nightly runs or things like that?

275
00:15:45,599 --> 00:15:46,599
Right.

276
00:15:46,599 --> 00:15:47,599
So I could do that.

277
00:15:47,599 --> 00:15:53,239
So actually the scripting infrastructure allowed to rerun any number of entries or all of them

278
00:15:53,239 --> 00:15:55,520
if I wanted to.

279
00:15:55,520 --> 00:16:01,599
And I did it typically, I mean, so the thing is, I wasn't, initially I wasn't really interested

280
00:16:01,599 --> 00:16:04,400
that much in this leaderboard and like, who is the fastest?

281
00:16:04,400 --> 00:16:08,880
For me, it was more, Hey, let's learn about this stuff and find out something.

282
00:16:08,880 --> 00:16:11,479
But then people are, I want to be the fastest one, right?

283
00:16:11,479 --> 00:16:13,840
So they care a lot about the leaderboard.

284
00:16:13,840 --> 00:16:19,239
And so that's why at some point I rerun, let's say the top 25 entries or so with different

285
00:16:19,239 --> 00:16:20,239
configurations.

286
00:16:20,239 --> 00:16:26,559
For instance, I wanted to run with all the 32 CPU cores with hyper-threading and so on.

287
00:16:26,559 --> 00:16:31,000
And so I did that at some point and then, you know, the scripting allowed to rerun those

288
00:16:31,000 --> 00:16:35,520
25 or whatever entries with a specific configuration.

289
00:16:35,520 --> 00:16:39,039
I would really love to now jump more to submissions.

290
00:16:39,039 --> 00:16:40,039
Yes.

291
00:16:40,039 --> 00:16:41,039
Can we do that?

292
00:16:41,599 --> 00:16:42,599
Sure.

293
00:16:42,599 --> 00:16:48,200
So obviously when I explained first time this challenge to Andraž, he said, well, you guys.

294
00:16:48,200 --> 00:16:56,000
The funny part was like, I was like, I'm doing that for a customer without actually, well,

295
00:16:56,000 --> 00:16:58,080
it's not the same.

296
00:16:58,080 --> 00:17:00,400
I think there is a bit of a less of data.

297
00:17:00,400 --> 00:17:03,919
Explain the customer case, perhaps, just so we have like a...

298
00:17:03,919 --> 00:17:09,880
We get all the permits from the US, so building permits, because there are public data.

299
00:17:09,880 --> 00:17:15,239
And then of course you get that raw data and you need to normalize it.

300
00:17:15,239 --> 00:17:22,560
And the catch is we do not seek for SAP one minute, whatever.

301
00:17:22,560 --> 00:17:29,719
It just needs to be relatively simple to understand for a senior.

302
00:17:29,719 --> 00:17:31,660
We don't want to write.

303
00:17:31,660 --> 00:17:37,520
So every line of custom code or regex that I write or whatever complicated, it's not

304
00:17:37,520 --> 00:17:38,520
a benefit.

305
00:17:38,520 --> 00:17:39,520
It's a curse, right?

306
00:17:40,160 --> 00:17:41,160
Yeah.

307
00:17:41,160 --> 00:17:42,160
And for...

308
00:17:42,160 --> 00:17:45,560
So I wasn't the author of the solution.

309
00:17:45,560 --> 00:17:52,079
There was a funny, funny detail, which is you just basically install in a Docker container.

310
00:17:52,079 --> 00:17:55,920
And then I think it was like, not that complicated code.

311
00:17:55,920 --> 00:17:56,920
It's something similar.

312
00:17:56,920 --> 00:18:01,160
We split the different states.

313
00:18:01,160 --> 00:18:02,400
And yeah, I do it that way.

314
00:18:02,400 --> 00:18:03,400
And it runs.

315
00:18:03,400 --> 00:18:04,400
I don't know.

316
00:18:04,400 --> 00:18:05,400
I don't know the data set.

317
00:18:05,400 --> 00:18:07,199
It changes, of course, all the time.

318
00:18:07,199 --> 00:18:10,239
Maybe it runs half an hour, but it's okay.

319
00:18:10,239 --> 00:18:11,400
It's streaming, right?

320
00:18:11,400 --> 00:18:15,160
Because Unix pipelines are basically streams.

321
00:18:15,160 --> 00:18:16,479
There's a funny detail.

322
00:18:16,479 --> 00:18:22,040
It stopped working when I was moving that to another environment, because I was using...

323
00:18:22,040 --> 00:18:30,280
So the colleague who wrote it was using GNU-AUC, of course, M-AUC or I don't know what the default

324
00:18:30,280 --> 00:18:36,280
installation on a different system was not working with a silent error, like exiting

325
00:18:36,359 --> 00:18:41,520
with zero, not outputting anything.

326
00:18:41,520 --> 00:18:43,959
So yeah, when I heard of this challenge, I was like...

327
00:18:43,959 --> 00:18:49,040
Because I tend to...

328
00:18:49,040 --> 00:18:50,800
I understand, yeah, you have this challenge.

329
00:18:50,800 --> 00:18:54,319
The catch is to learn something new, to optimize really fast.

330
00:18:54,319 --> 00:18:56,800
But I usually look at problems.

331
00:18:56,800 --> 00:18:58,640
I'm like, okay, I have this challenge.

332
00:18:58,640 --> 00:19:03,280
How can I make it so people will understand it for the next 10 years?

333
00:19:03,280 --> 00:19:04,280
Right.

334
00:19:04,280 --> 00:19:05,280
Oh, yes.

335
00:19:05,280 --> 00:19:10,439
So the payoff there in the challenge is, I mean, I did a very simple baseline implementation

336
00:19:10,439 --> 00:19:13,839
and this one ran in approximately five minutes.

337
00:19:13,839 --> 00:19:15,920
Pretty canonical Java code, I would say.

338
00:19:15,920 --> 00:19:22,160
And then improving all of that by one order of magnitude, so taking it to 20 or 30 seconds,

339
00:19:22,160 --> 00:19:25,760
you can do this quite easily and the code will be still very well readable.

340
00:19:25,760 --> 00:19:29,640
So it's code I would write, like every Java programmer would write.

341
00:19:29,640 --> 00:19:33,719
And it's easy to understand, easy to maintain.

342
00:19:33,719 --> 00:19:36,880
But then if you want to go another order of magnitude, so you want to go down to like

343
00:19:36,880 --> 00:19:42,199
1.5 seconds, at the top of the readable, then it's getting really crazy.

344
00:19:42,199 --> 00:19:43,800
And this is like super dense code.

345
00:19:43,800 --> 00:19:49,239
You need like three lines of comments for each line of code to make sense out of it.

346
00:19:49,239 --> 00:19:52,880
And I wouldn't recommend people to go there in their usual day job, I guess.

347
00:19:52,880 --> 00:19:55,680
I want to slow you down just a bit there.

348
00:19:55,680 --> 00:19:59,640
I broke this down to like three levels.

349
00:19:59,640 --> 00:20:00,640
So if level...

350
00:20:00,640 --> 00:20:01,640
Getting ahead of ourselves.

351
00:20:01,640 --> 00:20:05,199
Let's take it slowly because we want to go deep on these details.

352
00:20:05,199 --> 00:20:09,079
Level one would, let's say, be a AOC solution.

353
00:20:09,079 --> 00:20:12,040
Or in your case, baseline, you're a Java professional.

354
00:20:12,040 --> 00:20:13,040
So obviously five minutes.

355
00:20:13,040 --> 00:20:19,439
That's kind of like five minutes, 10 minutes is like average, or perhaps more senior engineer

356
00:20:19,439 --> 00:20:22,760
would take it like that or do an AOC solution.

357
00:20:22,760 --> 00:20:32,040
And that's, we said, 12 or 13 gigabytes of file, a billion rows is the process.

358
00:20:32,040 --> 00:20:33,760
And that's like a baseline.

359
00:20:33,760 --> 00:20:38,959
How far on the list of top submissions would that get you?

360
00:20:38,959 --> 00:20:41,760
Would that get you in the top 25 even or?

361
00:20:41,760 --> 00:20:42,760
No.

362
00:20:42,760 --> 00:20:45,040
As is today, no.

363
00:20:45,040 --> 00:20:49,400
You would be very much at the end of this sort of solution.

364
00:20:49,400 --> 00:20:50,400
I don't know.

365
00:20:50,400 --> 00:20:55,479
To be at the top 20 or so, or maybe top 30 would have to be below 10 seconds.

366
00:20:55,479 --> 00:20:57,479
Below 10 seconds.

367
00:20:57,479 --> 00:20:58,479
Okay.

368
00:20:58,479 --> 00:20:59,479
Yes.

369
00:20:59,479 --> 00:21:00,479
Okay.

370
00:21:00,479 --> 00:21:05,199
We spoke in this conference with three engineers that did take the challenge.

371
00:21:05,199 --> 00:21:08,119
We spoke with two senior engineers.

372
00:21:08,119 --> 00:21:13,959
Best times we have is around a minute and 74 seconds.

373
00:21:13,959 --> 00:21:15,560
So these are like Slovenian times.

374
00:21:15,560 --> 00:21:16,560
Okay.

375
00:21:16,560 --> 00:21:17,560
It's good.

376
00:21:17,560 --> 00:21:18,560
And it's impressive.

377
00:21:18,719 --> 00:21:20,319
I mean, my own implementation was like five minutes.

378
00:21:20,319 --> 00:21:22,599
I'm at the end of the leaderboard.

379
00:21:22,599 --> 00:21:25,640
I was always the slowest one.

380
00:21:25,640 --> 00:21:32,719
And both of these solutions that are still very good in the leaderboards, both of these

381
00:21:32,719 --> 00:21:36,640
solutions are, as you said, readable.

382
00:21:36,640 --> 00:21:38,239
So people can understand them.

383
00:21:38,239 --> 00:21:41,939
They're like still single file, standard APIs.

384
00:21:41,939 --> 00:21:45,439
You can maintain them and it's good, good modern Java code.

385
00:21:45,439 --> 00:21:48,719
I think it uses GraalVM as well on both cases, but it's cool.

386
00:21:48,719 --> 00:21:51,560
So if you write like that, you're good.

387
00:21:51,560 --> 00:21:52,560
Yeah.

388
00:21:52,560 --> 00:21:53,560
Yeah.

389
00:21:53,560 --> 00:21:54,560
It totally depends on what you want to do.

390
00:21:54,560 --> 00:21:55,560
Right.

391
00:21:55,560 --> 00:21:58,900
So if you need to run this like once per week or whatever, it's perfectly fine.

392
00:21:58,900 --> 00:22:04,520
If you want to win a coffee mug in a challenge, you'll probably need to do some more.

393
00:22:04,520 --> 00:22:05,520
Okay.

394
00:22:05,520 --> 00:22:08,680
But now let's go to level below.

395
00:22:08,680 --> 00:22:09,680
Okay.

396
00:22:09,680 --> 00:22:13,520
We also spoke with Peter Lewart.

397
00:22:13,520 --> 00:22:15,800
He's a Slovenian guy.

398
00:22:15,800 --> 00:22:18,319
He's the best Slovenian guy.

399
00:22:18,319 --> 00:22:23,280
His time is four seconds and 293 seconds.

400
00:22:23,280 --> 00:22:28,760
And yesterday we had a pleasure of talking to him and he guides us through the whole

401
00:22:28,760 --> 00:22:31,359
solution that he wrote.

402
00:22:31,359 --> 00:22:34,040
I will not pretend that I understand all of this.

403
00:22:34,040 --> 00:22:35,359
It's really dense code.

404
00:22:35,359 --> 00:22:38,640
So for four seconds, it has to be like really, really tough.

405
00:22:38,640 --> 00:22:44,239
What was really surprising was that he aimed to build a solution of his, and I'll link

406
00:22:44,239 --> 00:22:46,680
all this stuff there below.

407
00:22:46,680 --> 00:22:54,119
He tried to aim to not use unsafe, so he still uses Java APIs.

408
00:22:54,119 --> 00:22:59,640
But we can perhaps break down his solution just a bit, or at least what I called, but

409
00:22:59,640 --> 00:23:01,199
you can expand it.

410
00:23:01,199 --> 00:23:05,160
So first thing is like memory mapping.

411
00:23:05,160 --> 00:23:06,160
Right.

412
00:23:06,160 --> 00:23:10,439
So this is something that I think it gets common when you go below these numbers.

413
00:23:10,439 --> 00:23:15,680
And the idea there is that what you read a file and you map it into a memory, and then

414
00:23:15,680 --> 00:23:17,880
you start walking around.

415
00:23:17,880 --> 00:23:18,880
What was the idea there?

416
00:23:18,880 --> 00:23:20,560
Can you tell us a bit more about that?

417
00:23:20,560 --> 00:23:24,560
So I mean, what pretty much most people did at the top of the leaderboard was yes, to

418
00:23:24,560 --> 00:23:30,439
memory map the file and it will be mapped into off heap memory, which means that there

419
00:23:30,439 --> 00:23:34,400
is no garbage collection, you know, interfering with that.

420
00:23:34,400 --> 00:23:39,000
You are just in control of managing that by yourself.

421
00:23:39,000 --> 00:23:47,239
There's a new Java API, the foreign function and memory API, which people used, which allows

422
00:23:47,239 --> 00:23:54,000
it amongst other things to map this entire 13 gig file into one memory segment.

423
00:23:54,000 --> 00:23:59,319
So before you also could do memory map files with Java, but you were limited to two gigabytes

424
00:23:59,319 --> 00:24:01,800
with the direct byte buffer in the past.

425
00:24:01,800 --> 00:24:06,479
And nowadays you can, you know, map the entire thing all at once, no garbage collection.

426
00:24:06,479 --> 00:24:10,000
And yes, that's, that's what people did.

427
00:24:10,000 --> 00:24:14,040
From which version of Java do you get these things?

428
00:24:14,040 --> 00:24:19,439
It's I'm not sure when it got promoted to stable, but recently, maybe like 20 or 21,

429
00:24:19,439 --> 00:24:24,319
it got promoted out of incubator into the stable one.

430
00:24:24,319 --> 00:24:28,079
We also met the vector APIs here at this stage, right?

431
00:24:28,079 --> 00:24:29,079
Right.

432
00:24:29,079 --> 00:24:30,599
Can you tell us a bit more what that is?

433
00:24:30,599 --> 00:24:31,599
Right.

434
00:24:32,400 --> 00:24:33,400
I don't want to be confused with collection.

435
00:24:33,400 --> 00:24:34,400
Oh, yes.

436
00:24:34,400 --> 00:24:35,400
Oh, exactly.

437
00:24:35,400 --> 00:24:36,400
Yes.

438
00:24:36,400 --> 00:24:40,920
And this actually was one of the things I was really hoping that people would use because

439
00:24:40,920 --> 00:24:44,119
personally I'm just super interested in it and people did use it.

440
00:24:44,119 --> 00:24:45,119
Yes.

441
00:24:45,119 --> 00:24:51,000
So the idea there is that your CPUs, they have extensions to the instruction sets, which

442
00:24:51,000 --> 00:24:56,880
allow to apply the same operation to multiple operands at once.

443
00:24:56,880 --> 00:25:00,000
So you can do the same thing for multiple values.

444
00:25:00,000 --> 00:25:03,540
in parallel, and you know, if you apply the same operation,

445
00:25:03,540 --> 00:25:07,600
like a comparison or whatever, to eight operands at once,

446
00:25:07,600 --> 00:25:09,880
you know, this might be eight times faster in theory.

447
00:25:09,880 --> 00:25:11,600
And this is called SIMD,

448
00:25:11,600 --> 00:25:14,280
so single instruction, multiple data.

449
00:25:14,280 --> 00:25:18,200
And so, you know, things like Intel CPUs,

450
00:25:18,200 --> 00:25:23,200
they have AVX2 with AVX512 instruction set extensions,

451
00:25:23,280 --> 00:25:27,680
which provide a wide range of those vectorized operations.

452
00:25:27,680 --> 00:25:32,639
And the thing is, in Java, until recently,

453
00:25:32,639 --> 00:25:36,200
you couldn't really use those extensions,

454
00:25:36,200 --> 00:25:37,919
not directly as a Java developer.

455
00:25:37,919 --> 00:25:42,080
So the Java compiler would auto-vectorize code

456
00:25:42,080 --> 00:25:44,080
in specific situations.

457
00:25:44,080 --> 00:25:45,799
If it, you know, you had like a loop,

458
00:25:45,799 --> 00:25:47,919
and the compiler would detect specific patterns,

459
00:25:47,919 --> 00:25:50,720
then it might be able to emit vectorized code,

460
00:25:50,720 --> 00:25:52,759
which make use of those SIMD instructions.

461
00:25:52,759 --> 00:25:56,480
But you, as a application developer, you couldn't use that.

462
00:25:56,480 --> 00:25:59,040
And this is changing now with this vector API,

463
00:25:59,040 --> 00:26:00,279
and it's still in incubating state,

464
00:26:00,279 --> 00:26:03,720
I think like the eighth or ninth incubating release.

465
00:26:03,720 --> 00:26:05,199
So it's, you know, baking for some time,

466
00:26:05,199 --> 00:26:07,879
but you can use it already as a preview feature.

467
00:26:07,879 --> 00:26:09,919
And the interesting thing there is,

468
00:26:09,919 --> 00:26:12,000
you can now do those things.

469
00:26:12,000 --> 00:26:14,279
You can say, okay, I want to, you know,

470
00:26:14,279 --> 00:26:16,760
I want to look for a line-ending byte

471
00:26:16,760 --> 00:26:21,519
in eight or 16 bytes at once.

472
00:26:21,519 --> 00:26:25,879
And the nice thing about this is, this is a Java API,

473
00:26:25,879 --> 00:26:28,959
so it's portable because with other languages,

474
00:26:28,959 --> 00:26:32,559
let's say Rust or C, you also can use those instructions,

475
00:26:32,559 --> 00:26:35,040
but you would go down essentially to assembly level,

476
00:26:35,040 --> 00:26:38,199
and you would be specific to the architecture

477
00:26:38,199 --> 00:26:40,919
you're running on, and your program wouldn't be portable.

478
00:26:40,919 --> 00:26:43,279
Whereas with the Java API, it actually is portable

479
00:26:43,279 --> 00:26:45,599
because the JVM takes care of, you know,

480
00:26:45,599 --> 00:26:47,440
compiling this to Intel instructions

481
00:26:47,440 --> 00:26:50,360
or Neon instructions on ARM.

482
00:26:50,360 --> 00:26:52,800
And now I feel like we, as Java developers,

483
00:26:52,800 --> 00:26:54,519
actually are at an advantage

484
00:26:54,519 --> 00:26:57,239
because we can use vectorized APIs

485
00:26:57,239 --> 00:26:59,800
and still we are portable across platforms.

486
00:26:59,800 --> 00:27:00,639
Beautiful.

487
00:27:00,639 --> 00:27:03,519
Would you say that that's like readable?

488
00:27:03,519 --> 00:27:04,680
Oh yeah, I think it's-

489
00:27:04,680 --> 00:27:06,559
Like for the level of-

490
00:27:06,559 --> 00:27:07,760
Right, I mean, you need to get

491
00:27:07,760 --> 00:27:08,960
a little bit of hang of it, right?

492
00:27:08,960 --> 00:27:11,520
To understand, okay, I want to, you know,

493
00:27:11,520 --> 00:27:14,440
work on multiple elements of an array at the same time.

494
00:27:14,440 --> 00:27:15,800
Then there's also this thing,

495
00:27:15,800 --> 00:27:18,960
like you always have like a remainder of your data.

496
00:27:18,960 --> 00:27:20,520
So let's say for the sake of the example,

497
00:27:20,520 --> 00:27:23,919
you work on an array, which is like 20 bytes long,

498
00:27:24,320 --> 00:27:25,839
and you can process eight bytes

499
00:27:25,839 --> 00:27:27,199
with vectorized instructions.

500
00:27:27,199 --> 00:27:29,320
So you can do this twice, like first eight,

501
00:27:29,320 --> 00:27:31,880
second eight, and then you have like four bytes left.

502
00:27:31,880 --> 00:27:34,199
And then you typically have to do this

503
00:27:34,199 --> 00:27:38,000
like in a scalar way, you know, for the remainder.

504
00:27:38,000 --> 00:27:41,279
So there's, you know, things you need to understand

505
00:27:41,279 --> 00:27:43,399
and make you like learn about.

506
00:27:43,399 --> 00:27:44,919
But overall, I feel it's code,

507
00:27:44,919 --> 00:27:46,759
which still is fairly readable, yes.

508
00:27:46,759 --> 00:27:47,600
Awesome.

509
00:27:48,639 --> 00:27:52,600
The other thing next to memory mapping vectorization

510
00:27:52,600 --> 00:27:54,639
is usage of parallelism.

511
00:27:54,639 --> 00:27:57,880
So parallelize as much of computation as possible.

512
00:27:57,880 --> 00:27:58,720
Right.

513
00:27:58,720 --> 00:28:01,479
That is also, plays a big role in this optimization.

514
00:28:01,479 --> 00:28:03,039
At least that's my impression.

515
00:28:03,039 --> 00:28:03,880
Yes, absolutely.

516
00:28:03,880 --> 00:28:08,320
So you want to make use of all the CPU resources you have.

517
00:28:09,240 --> 00:28:12,320
And so coming back to like readable

518
00:28:12,320 --> 00:28:14,919
and, you know, maintainable solutions,

519
00:28:14,919 --> 00:28:16,559
if you use the Java Streams API,

520
00:28:16,559 --> 00:28:19,759
it could be as simple as adding a parallel method call,

521
00:28:19,759 --> 00:28:21,559
like, you know, calling this method parallel.

522
00:28:21,600 --> 00:28:24,520
And it would be parallelized to those eight cores

523
00:28:24,520 --> 00:28:27,160
and gives you a nice speed up.

524
00:28:27,160 --> 00:28:29,960
But what's happening there is, well,

525
00:28:29,960 --> 00:28:33,279
so the computation would be happening in parallel,

526
00:28:33,279 --> 00:28:35,080
but reading the file,

527
00:28:35,080 --> 00:28:36,919
that would still be a sequential thing.

528
00:28:36,919 --> 00:28:40,039
And this is where it goes back then to the memory map file.

529
00:28:40,039 --> 00:28:42,399
So this is something which you need to parallelize yourselves

530
00:28:42,399 --> 00:28:45,600
by using like threads and, you know,

531
00:28:45,600 --> 00:28:48,199
making sure you process different chunks

532
00:28:48,199 --> 00:28:50,919
of that memory segment with different threads

533
00:28:50,919 --> 00:28:52,759
and people absolutely did this.

534
00:28:52,759 --> 00:28:56,960
I think that, I think you mentioned this from your talk,

535
00:28:56,960 --> 00:29:00,119
that your baseline, you can correct me on this,

536
00:29:00,119 --> 00:29:01,479
your baseline was five minutes,

537
00:29:01,479 --> 00:29:04,639
but with usage of parallel APIs,

538
00:29:04,639 --> 00:29:07,199
you managed to get down to one minute with it or?

539
00:29:07,199 --> 00:29:09,759
Yeah, so it gets, I forgot the exact numbers,

540
00:29:09,759 --> 00:29:11,080
but it gets like four times faster.

541
00:29:11,080 --> 00:29:12,399
It doesn't get eight times faster

542
00:29:12,399 --> 00:29:14,960
because the file reading is not parallelized that way.

543
00:29:14,960 --> 00:29:17,600
But still it's a nice payout

544
00:29:17,600 --> 00:29:19,279
for like a simple method call, right?

545
00:29:19,279 --> 00:29:20,119
Yeah, it's amazing.

546
00:29:20,119 --> 00:29:22,760
Like you basically added just like a dot parallel.

547
00:29:22,760 --> 00:29:23,600
Exactly.

548
00:29:23,600 --> 00:29:24,440
That was it.

549
00:29:24,440 --> 00:29:26,519
And implicitly it is kind of a map reduce,

550
00:29:26,519 --> 00:29:31,519
kind of like wiggly and it's like an insane boost.

551
00:29:31,559 --> 00:29:32,399
Yes, exactly.

552
00:29:32,399 --> 00:29:35,320
If you compare maybe with other languages,

553
00:29:35,320 --> 00:29:36,959
then it would be much more trickier.

554
00:29:36,959 --> 00:29:37,799
Right, yeah.

555
00:29:37,799 --> 00:29:39,799
So good value for the money, I have to say.

556
00:29:39,799 --> 00:29:43,799
Before we jump more into like unsafe world.

557
00:29:43,799 --> 00:29:44,640
Oh, yeah.

558
00:29:45,559 --> 00:29:46,920
I do want to mention hacks.

559
00:29:46,920 --> 00:29:49,600
And like one of the hacks that you,

560
00:29:50,000 --> 00:29:51,040
I'm calling it hacks,

561
00:29:51,040 --> 00:29:55,480
but or clever approaches to solving this thing was like,

562
00:29:55,480 --> 00:29:58,480
one was where you mentioned that you took names

563
00:29:58,480 --> 00:30:01,399
and people consider to the collision, like keys, et cetera.

564
00:30:02,359 --> 00:30:06,959
One thing that we, I think was also in the levered solution

565
00:30:06,959 --> 00:30:11,239
was that taking the names of cities

566
00:30:11,239 --> 00:30:13,239
was not like very efficient.

567
00:30:13,239 --> 00:30:14,079
Right.

568
00:30:14,079 --> 00:30:15,440
So he got smart, for example,

569
00:30:15,440 --> 00:30:17,839
and he just took like a first character of the name

570
00:30:17,839 --> 00:30:19,480
and last character of the name.

571
00:30:20,239 --> 00:30:21,079
And use that as a key.

572
00:30:21,079 --> 00:30:21,920
Because for example,

573
00:30:21,920 --> 00:30:23,679
he found that that's going to consume less memory.

574
00:30:23,679 --> 00:30:24,640
It's going to be faster.

575
00:30:24,640 --> 00:30:27,119
And it's still kind of like less collision.

576
00:30:27,119 --> 00:30:32,119
So people find like these insane optimizations of some kind.

577
00:30:32,200 --> 00:30:33,959
And then there's of course the risk

578
00:30:33,959 --> 00:30:37,040
that you make assumptions about the specific key set, right?

579
00:30:37,040 --> 00:30:41,239
So this might be fine for a specific key set,

580
00:30:41,239 --> 00:30:43,839
but a solution was considered only valid

581
00:30:43,839 --> 00:30:46,079
if it worked for all possible keys.

582
00:30:46,079 --> 00:30:47,440
So doing something like that,

583
00:30:47,440 --> 00:30:49,480
you would still have to do like the fallback

584
00:30:49,480 --> 00:30:52,320
to comparing the full name.

585
00:30:52,320 --> 00:30:55,600
You know, if there's equality in the short version.

586
00:30:55,600 --> 00:30:56,600
Yeah, I see like.

587
00:30:56,600 --> 00:30:57,440
Right.

588
00:30:57,440 --> 00:30:58,839
Like, I'm not sure how like,

589
00:30:59,760 --> 00:31:02,119
they're very, these are like extreme optimizations

590
00:31:02,119 --> 00:31:02,959
to a degree.

591
00:31:02,959 --> 00:31:04,559
So like changing the file format,

592
00:31:04,559 --> 00:31:07,920
obviously all this stuff, you wouldn't benefit for it.

593
00:31:07,920 --> 00:31:09,320
Changing the values too much.

594
00:31:09,320 --> 00:31:10,720
Like all these things,

595
00:31:10,720 --> 00:31:12,640
probably the solutions are not that generic.

596
00:31:12,640 --> 00:31:14,640
It's like small cheating is like

597
00:31:14,679 --> 00:31:18,119
not implementing the whole hash map inside of it,

598
00:31:18,119 --> 00:31:19,399
but like doing.

599
00:31:19,399 --> 00:31:20,239
Right.

600
00:31:20,239 --> 00:31:21,880
I mean, so many people did custom hash maps,

601
00:31:21,880 --> 00:31:23,359
custom maps, I should say.

602
00:31:23,359 --> 00:31:26,000
And so what happens there is essentially

603
00:31:26,000 --> 00:31:28,119
you store the values in an array.

604
00:31:28,119 --> 00:31:31,200
You take the hash code of the key

605
00:31:31,200 --> 00:31:33,399
to find the index in the array.

606
00:31:33,399 --> 00:31:35,480
And then of course you need to handle collisions.

607
00:31:35,480 --> 00:31:37,279
So you need to, if you, you know,

608
00:31:37,279 --> 00:31:39,760
you go to this array bucket or to this element

609
00:31:39,760 --> 00:31:41,519
and there's a value there already,

610
00:31:41,519 --> 00:31:43,239
you need to compare, you know, the name.

611
00:31:43,239 --> 00:31:45,720
Is this the bucket I want to add to or not?

612
00:31:45,720 --> 00:31:46,559
And if it's not,

613
00:31:46,559 --> 00:31:49,160
you want to go to the next free slot in the array.

614
00:31:49,160 --> 00:31:51,399
And this created a bit of a nightmare for myself

615
00:31:51,399 --> 00:31:54,279
because you cannot test for that in an automated way.

616
00:31:54,279 --> 00:31:57,880
You cannot prove the absence of hash collisions in a test

617
00:31:57,880 --> 00:32:01,119
because people could use arbitrary hash functions,

618
00:32:01,119 --> 00:32:02,559
arbitrary seed values.

619
00:32:02,559 --> 00:32:05,239
So I always had to review for that.

620
00:32:05,239 --> 00:32:07,200
And it was like, you know,

621
00:32:07,200 --> 00:32:10,000
quite a bit of effort to understand.

622
00:32:10,000 --> 00:32:12,720
So actually in the pull request template, at some point,

623
00:32:12,720 --> 00:32:14,359
I made a comment.

624
00:32:14,359 --> 00:32:17,480
So if you have custom hash map implementations,

625
00:32:17,480 --> 00:32:20,480
point me to the place where you deal with collisions

626
00:32:20,480 --> 00:32:22,359
so that I could understand about it.

627
00:32:22,359 --> 00:32:27,200
I wonder if you would have like a team that would help you

628
00:32:27,200 --> 00:32:30,799
and you could delegate it and then like,

629
00:32:31,799 --> 00:32:33,480
like have a pre-review.

630
00:32:33,480 --> 00:32:34,320
Right, yeah.

631
00:32:34,320 --> 00:32:37,200
But I was thinking like, would that even help you?

632
00:32:37,200 --> 00:32:41,920
Or it would just like taint your view on the code

633
00:32:41,920 --> 00:32:43,040
if you know what I mean.

634
00:32:43,040 --> 00:32:44,040
Because then it's tricky.

635
00:32:44,040 --> 00:32:45,640
You may skip something else.

636
00:32:45,640 --> 00:32:46,480
Right, yeah.

637
00:32:46,480 --> 00:32:47,320
That's a good question.

638
00:32:47,320 --> 00:32:48,359
I didn't think about it.

639
00:32:48,359 --> 00:32:51,160
But I mean, actually people helped a lot already.

640
00:32:51,160 --> 00:32:53,720
People built this test suite,

641
00:32:53,720 --> 00:32:55,799
which initially I didn't have any tests.

642
00:32:55,799 --> 00:32:57,239
I wasn't really thinking of that.

643
00:32:57,239 --> 00:33:01,239
But people built this TCK, you know,

644
00:33:01,239 --> 00:33:04,920
test compatibility kit, which you had to pass.

645
00:33:04,920 --> 00:33:05,760
People did that.

646
00:33:05,760 --> 00:33:07,839
They helped with the environment, as I mentioned.

647
00:33:07,839 --> 00:33:10,480
They helped with just all the infrastructure

648
00:33:10,480 --> 00:33:11,320
for evaluations.

649
00:33:11,720 --> 00:33:14,000
There was a guy, James Nockland,

650
00:33:14,000 --> 00:33:16,839
who wrote like amazing shell scripts

651
00:33:16,839 --> 00:33:19,760
for making sure the environment is configured correctly.

652
00:33:19,760 --> 00:33:22,640
And then for, you know, running the benchmarks

653
00:33:22,640 --> 00:33:24,359
and with like colored outputs.

654
00:33:24,359 --> 00:33:25,920
So for me, it was just like a lesson.

655
00:33:25,920 --> 00:33:28,279
How do you write excellent shell scripts?

656
00:33:28,279 --> 00:33:30,799
This was a nice takeaway for me.

657
00:33:30,799 --> 00:33:33,599
Before I ask you how to go below,

658
00:33:33,599 --> 00:33:36,440
to get to the top or to below two seconds,

659
00:33:37,440 --> 00:33:41,599
you, I think that this challenge,

660
00:33:41,599 --> 00:33:44,119
I'm not sure if you published it on Hacker News

661
00:33:44,119 --> 00:33:45,880
or it somehow got into Hacker News.

662
00:33:45,880 --> 00:33:46,719
Right.

663
00:33:46,719 --> 00:33:49,599
What did that thing do to this challenger?

664
00:33:49,599 --> 00:33:50,440
Oh, yeah.

665
00:33:50,440 --> 00:33:54,039
No, actually, it could have been that I put it there,

666
00:33:54,039 --> 00:33:55,280
but somebody else also put it there.

667
00:33:55,280 --> 00:33:56,840
But yes, at some point it was actually

668
00:33:56,840 --> 00:33:59,280
on first place on Hacker News, which was great.

669
00:33:59,280 --> 00:34:01,479
Beautiful, congratulations.

670
00:34:01,479 --> 00:34:02,640
Thank you.

671
00:34:02,640 --> 00:34:04,679
You know, first time that I had that.

672
00:34:04,840 --> 00:34:08,479
And it definitely helped with, you know, popularity.

673
00:34:08,479 --> 00:34:10,200
People, more people learned about it,

674
00:34:10,200 --> 00:34:11,559
more people contribute.

675
00:34:11,559 --> 00:34:13,599
And then of course you also have like

676
00:34:13,599 --> 00:34:16,159
the typical Hacker News guy, right?

677
00:34:16,159 --> 00:34:17,239
Commenting there.

678
00:34:17,239 --> 00:34:18,880
And there was like the one comment,

679
00:34:18,880 --> 00:34:22,200
actually, I had it in the keynote earlier this morning.

680
00:34:22,200 --> 00:34:23,039
Yeah.

681
00:34:23,039 --> 00:34:24,440
How hard, this is not a hard problem.

682
00:34:24,440 --> 00:34:25,359
It's a trivial problem.

683
00:34:25,359 --> 00:34:27,280
Like everybody who can program a little bit,

684
00:34:27,280 --> 00:34:29,400
they can solve this in like half an hour.

685
00:34:29,400 --> 00:34:30,679
And then, yeah, sure.

686
00:34:30,679 --> 00:34:33,840
Like guys like Thomas Wirtinger and Alexey Shipilev

687
00:34:33,840 --> 00:34:36,159
and Cliff Click and all the other big hitters.

688
00:34:36,159 --> 00:34:37,799
They spent like an entire month

689
00:34:37,799 --> 00:34:41,159
to optimize this, right?

690
00:34:41,159 --> 00:34:43,719
And like going down to the instruction level.

691
00:34:43,719 --> 00:34:45,599
Then you have like the Hacker News guy,

692
00:34:45,599 --> 00:34:46,440
how hard can it be?

693
00:34:46,440 --> 00:34:47,840
I do it in like in 30 minutes.

694
00:34:47,840 --> 00:34:48,679
Yeah.

695
00:34:48,679 --> 00:34:49,520
Yeah.

696
00:34:49,520 --> 00:34:50,359
Yeah.

697
00:34:50,359 --> 00:34:52,159
It's always like that, but it's funny.

698
00:34:52,159 --> 00:34:53,640
Again, you get, it gets the,

699
00:34:53,640 --> 00:34:55,239
on the surface it looks easy,

700
00:34:55,239 --> 00:34:57,119
which is for such a challenge, it's really nice

701
00:34:57,119 --> 00:34:59,239
because it appeals to people.

702
00:34:59,239 --> 00:35:00,080
Right.

703
00:35:00,080 --> 00:35:00,919
You can explain it easily.

704
00:35:00,919 --> 00:35:02,960
Easily explain, rules are simple.

705
00:35:02,960 --> 00:35:03,799
Right.

706
00:35:04,559 --> 00:35:05,400
Their results are,

707
00:35:05,400 --> 00:35:07,000
you either have the results or you don't.

708
00:35:07,000 --> 00:35:08,200
So it's like indisputable.

709
00:35:08,200 --> 00:35:09,440
Yes.

710
00:35:09,440 --> 00:35:10,280
Yeah.

711
00:35:10,280 --> 00:35:11,119
It's challenging.

712
00:35:11,119 --> 00:35:11,960
I love it.

713
00:35:11,960 --> 00:35:13,719
I also think this will be, you know,

714
00:35:13,719 --> 00:35:15,679
the biggest challenge next year,

715
00:35:15,679 --> 00:35:17,280
if you wanted to do it again,

716
00:35:17,280 --> 00:35:19,039
to find another problem, which is like that.

717
00:35:19,039 --> 00:35:21,000
So you can explain it easily

718
00:35:21,000 --> 00:35:22,520
and still it has lots of potential

719
00:35:22,520 --> 00:35:24,719
because I think you could find things, you know,

720
00:35:24,719 --> 00:35:26,400
which are also very tough

721
00:35:26,400 --> 00:35:29,280
and which give you enough substance

722
00:35:29,280 --> 00:35:31,239
to work on for an entire month.

723
00:35:31,239 --> 00:35:33,760
But it would also take you half an hour to explain it.

724
00:35:34,599 --> 00:35:35,440
And that would make it, I think,

725
00:35:35,440 --> 00:35:36,799
much less appealing, as you say.

726
00:35:37,960 --> 00:35:41,080
Like from the outside world,

727
00:35:41,080 --> 00:35:44,000
like people ask, why would you do this stuff?

728
00:35:44,000 --> 00:35:45,520
And I keep telling them, like,

729
00:35:45,520 --> 00:35:47,080
that's completely wrong question.

730
00:35:47,080 --> 00:35:48,760
That's, you should never ask that.

731
00:35:48,760 --> 00:35:49,599
Right.

732
00:35:49,599 --> 00:35:50,440
Because we can, right?

733
00:35:50,440 --> 00:35:52,280
Not because you can, but equal,

734
00:35:52,280 --> 00:35:54,479
like you wouldn't understand the answer to that question

735
00:35:54,479 --> 00:35:56,000
even if I provided one.

736
00:35:56,000 --> 00:35:57,000
To be honest, like,

737
00:35:57,000 --> 00:36:00,760
I think that this challenge is one of super useful.

738
00:36:00,760 --> 00:36:05,000
Like, it's pretty commonly that you get like

739
00:36:05,000 --> 00:36:06,960
large files of text

740
00:36:06,960 --> 00:36:09,840
that you need to do some transformation on them

741
00:36:09,840 --> 00:36:13,440
and then maybe save them as a per key file or whatever.

742
00:36:13,440 --> 00:36:15,719
So I think that this one is really realistic,

743
00:36:15,719 --> 00:36:18,559
especially now in these golden data science,

744
00:36:18,559 --> 00:36:21,679
AI learning days.

745
00:36:21,679 --> 00:36:24,719
And I think that this one is really the most applicable

746
00:36:24,719 --> 00:36:26,599
I've seen so far, if you ask me.

747
00:36:26,599 --> 00:36:27,440
Yeah.

748
00:36:27,440 --> 00:36:29,640
I mean, it has been on my mind for a while

749
00:36:29,640 --> 00:36:32,119
to do something with a billion rows.

750
00:36:32,119 --> 00:36:32,960
Yeah.

751
00:36:32,960 --> 00:36:35,080
And then at some point I thought, okay, let's do it.

752
00:36:35,080 --> 00:36:36,479
And I think it's particularly interesting,

753
00:36:36,479 --> 00:36:38,799
of course, if you work on tooling around it, right?

754
00:36:38,799 --> 00:36:41,559
So if you were to create a database

755
00:36:41,559 --> 00:36:43,960
or work on tools like Org, I guess,

756
00:36:43,960 --> 00:36:46,880
then of course you would imply all those techniques.

757
00:36:47,840 --> 00:36:48,679
Okay.

758
00:36:48,679 --> 00:36:49,520
Question.

759
00:36:49,520 --> 00:36:50,960
How do you go below two seconds?

760
00:36:52,200 --> 00:36:53,039
Yeah.

761
00:36:53,039 --> 00:36:56,960
I mean, perhaps like, if not a Java developer,

762
00:36:56,960 --> 00:36:58,840
Java has this kind of like,

763
00:36:58,840 --> 00:37:00,359
I don't want to say bad reputation,

764
00:37:00,359 --> 00:37:03,599
but like people say, you know,

765
00:37:03,599 --> 00:37:05,200
it's not performant anymore.

766
00:37:05,200 --> 00:37:08,119
It's not suitable because of the garbage collection

767
00:37:08,119 --> 00:37:11,960
and you should just reuse Rust and things will be magical.

768
00:37:11,960 --> 00:37:13,359
Right.

769
00:37:13,359 --> 00:37:15,840
But like the leaderboard speaks for itself.

770
00:37:15,840 --> 00:37:16,679
Right.

771
00:37:16,679 --> 00:37:20,039
So, I mean, obviously the top implementation

772
00:37:20,039 --> 00:37:23,280
there are crazy optimized people doing insane stuff.

773
00:37:23,280 --> 00:37:27,039
But like these times are still acceptable,

774
00:37:27,080 --> 00:37:29,359
reasonable for the given challenge.

775
00:37:29,359 --> 00:37:33,960
So Java is still very, very much relevant in this space,

776
00:37:33,960 --> 00:37:35,679
even in big data, machine learning,

777
00:37:35,679 --> 00:37:37,119
all these things, it's there.

778
00:37:37,119 --> 00:37:39,119
And this was also exactly one of the things

779
00:37:39,119 --> 00:37:40,799
which I wanted to get out of this challenge,

780
00:37:40,799 --> 00:37:45,679
to make this case and to help debunk this misconception.

781
00:37:45,679 --> 00:37:48,119
And I think people definitely learned about it.

782
00:37:48,119 --> 00:37:48,960
Okay.

783
00:37:48,960 --> 00:37:51,799
So my understanding of what it takes

784
00:37:51,799 --> 00:37:54,520
to go under two seconds, I'll try to summarize it,

785
00:37:54,520 --> 00:37:55,760
but you'll expand this.

786
00:37:55,760 --> 00:37:56,679
Okay.

787
00:37:57,200 --> 00:38:02,200
So different distributions of JVM.

788
00:38:02,719 --> 00:38:03,559
Right.

789
00:38:03,559 --> 00:38:05,679
That kind of helps.

790
00:38:05,679 --> 00:38:10,679
With GraalVM, we get this ability to do,

791
00:38:11,000 --> 00:38:14,799
like do the more binary way of things,

792
00:38:14,799 --> 00:38:17,280
compile stuff into binary, run that.

793
00:38:17,280 --> 00:38:18,119
Exactly.

794
00:38:18,119 --> 00:38:19,919
I think that is kind of like where a lot

795
00:38:19,919 --> 00:38:22,520
of these solutions build upon that.

796
00:38:22,520 --> 00:38:23,520
You want to explain that perhaps?

797
00:38:23,520 --> 00:38:24,359
Yes.

798
00:38:24,359 --> 00:38:25,520
I mean, a few thoughts on GraalVM.

799
00:38:25,520 --> 00:38:27,799
So first of all, I mean, it also can be used

800
00:38:27,799 --> 00:38:30,440
as a JIT compiler, just-in-time compiler, right?

801
00:38:30,440 --> 00:38:34,200
As a replacement of the C2 compiler in your JVM.

802
00:38:34,200 --> 00:38:37,559
And even doing that, actually for this particular workload,

803
00:38:37,559 --> 00:38:39,719
gave a nice improvement of a few percent.

804
00:38:39,719 --> 00:38:42,200
And this is, I think, also an interesting takeaway.

805
00:38:42,200 --> 00:38:46,400
Just try GraalVM as your JVM.

806
00:38:46,400 --> 00:38:48,559
You know, not thinking about native compilation

807
00:38:48,559 --> 00:38:51,880
or whatever, it might give you an improvement

808
00:38:51,880 --> 00:38:53,919
in terms of throughput and latency,

809
00:38:54,039 --> 00:38:55,679
essentially for free, right?

810
00:38:55,679 --> 00:38:56,599
So that's one thing.

811
00:38:56,599 --> 00:38:58,559
But then yes, of course, people like GraalVM

812
00:38:58,559 --> 00:39:01,919
also because it does the ahead-of-time compilation.

813
00:39:01,919 --> 00:39:05,440
And now I did not expect the times to go

814
00:39:05,440 --> 00:39:08,440
into that low range where this would make a difference,

815
00:39:08,440 --> 00:39:10,239
but actually people ended up going there, right?

816
00:39:10,239 --> 00:39:15,239
And because now what happens is all the compilation happens,

817
00:39:15,520 --> 00:39:17,000
well, it builds time.

818
00:39:17,000 --> 00:39:19,039
So we don't have to just time compiler.

819
00:39:19,039 --> 00:39:21,119
There's no interpreted phase.

820
00:39:21,119 --> 00:39:22,520
The compiler doesn't need to warm up,

821
00:39:22,520 --> 00:39:23,559
all this kind of stuff,

822
00:39:24,200 --> 00:39:27,039
which means we have like peak performance right early on.

823
00:39:27,039 --> 00:39:30,159
And your process is to start up faster.

824
00:39:30,159 --> 00:39:34,200
And now, well, if you look at those times,

825
00:39:34,200 --> 00:39:38,000
like 1.5 seconds at the top of the leaderboard,

826
00:39:38,000 --> 00:39:41,000
if you are faster to start up by 200 milliseconds,

827
00:39:41,000 --> 00:39:43,960
that's a significant difference in that range, right?

828
00:39:43,960 --> 00:39:45,080
And that's why, yes,

829
00:39:45,080 --> 00:39:46,880
people at the very top of the leaderboard,

830
00:39:46,880 --> 00:39:49,960
they decided to use GraalVM native binaries,

831
00:39:49,960 --> 00:39:52,200
which for me made life actually a bit harder

832
00:39:52,200 --> 00:39:54,320
because the compilation takes a little bit longer.

833
00:39:54,320 --> 00:39:55,960
So whenever I ran those entries,

834
00:39:55,960 --> 00:39:57,919
then I had to spend some more time

835
00:39:57,919 --> 00:39:59,359
for building those binaries.

836
00:39:59,359 --> 00:40:01,280
But even like in production setups,

837
00:40:01,280 --> 00:40:04,159
you, if you do ahead of time compilation,

838
00:40:04,159 --> 00:40:06,000
you're willing to sacrifice more time

839
00:40:06,000 --> 00:40:11,000
and more time because you get speed up in the runtime, right?

840
00:40:11,159 --> 00:40:12,400
Okay, that's one.

841
00:40:12,400 --> 00:40:16,000
And then the unsafe world, that's a big thing.

842
00:40:16,000 --> 00:40:17,000
Right, there's unsafe.

843
00:40:17,000 --> 00:40:17,840
Yes, exactly.

844
00:40:17,840 --> 00:40:22,320
And essentially, it bypasses all those boundary checks

845
00:40:22,320 --> 00:40:27,320
and it allows you to directly work on this memory data.

846
00:40:27,359 --> 00:40:30,760
So it's, again, a bit faster.

847
00:40:30,760 --> 00:40:33,559
Also, of course, like, well, unsafe, literally.

848
00:40:33,559 --> 00:40:35,679
So I remember Roy van Rijn,

849
00:40:35,679 --> 00:40:36,880
one of the top contenders,

850
00:40:36,880 --> 00:40:41,880
when he played around with unsafe, he did it wrong.

851
00:40:42,400 --> 00:40:43,880
I mean, you get stuff wrong, right?

852
00:40:43,880 --> 00:40:44,880
It's just natural.

853
00:40:44,880 --> 00:40:48,239
And then, well, in that case, the JVM just crashes.

854
00:40:48,239 --> 00:40:53,239
And so he shared a screenshot of his like 30 JVM crash logs.

855
00:40:53,359 --> 00:40:56,799
So, you know, it's a bit more frustrating, I guess,

856
00:40:56,799 --> 00:40:58,919
in terms of a developer experience to do that.

857
00:40:58,919 --> 00:41:00,919
But yes, so that's one thing.

858
00:41:00,919 --> 00:41:02,440
And what I also found interesting,

859
00:41:02,440 --> 00:41:05,280
you can disable garbage collection altogether

860
00:41:05,280 --> 00:41:07,119
if you implement it the right way.

861
00:41:07,119 --> 00:41:10,559
Because if you don't allocate any objects

862
00:41:10,559 --> 00:41:12,760
in like your inner processing loop,

863
00:41:12,760 --> 00:41:14,000
you don't need garbage collection,

864
00:41:14,000 --> 00:41:16,400
which means you can, you know,

865
00:41:16,400 --> 00:41:17,919
spend those CPU cycles then

866
00:41:17,919 --> 00:41:20,400
for working on your actual computations.

867
00:41:20,400 --> 00:41:22,119
And again, it's just a bit faster.

868
00:41:22,119 --> 00:41:24,320
So that's what some people did.

869
00:41:24,320 --> 00:41:27,479
And I think that's also very applicable to other problems.

870
00:41:27,479 --> 00:41:30,000
So let's say you were to use Java for, let's say,

871
00:41:30,000 --> 00:41:33,320
a CLI tool, a very short-lived process.

872
00:41:33,320 --> 00:41:35,880
Maybe you just can disable garbage collection altogether,

873
00:41:35,880 --> 00:41:37,599
and it will be a bit faster.

874
00:41:37,599 --> 00:41:40,880
Well, one thing there is that my understanding was

875
00:41:40,880 --> 00:41:45,440
that top solutions also don't use a lot of objects as well.

876
00:41:45,440 --> 00:41:47,919
They try to use as little objects as possible

877
00:41:47,919 --> 00:41:49,719
and try to optimize that as well, not much.

878
00:41:49,719 --> 00:41:50,559
Yes, absolutely.

879
00:41:50,559 --> 00:41:53,919
So, you know, they would work with the byte arrays directly

880
00:41:53,919 --> 00:41:57,520
or maybe making a string object point

881
00:41:57,520 --> 00:42:01,080
to a specific section of the memory segment.

882
00:42:01,080 --> 00:42:03,359
Yes, all that to avoid allocating objects

883
00:42:03,359 --> 00:42:04,359
as much as possible.

884
00:42:05,359 --> 00:42:14,359
One thing that I also learned by talking to Levert

885
00:42:14,359 --> 00:42:16,680
in his four-second solution,

886
00:42:16,680 --> 00:42:21,520
that he spent a lot of time running the compilation

887
00:42:21,520 --> 00:42:24,719
with some additional flags so that he actually sees

888
00:42:24,719 --> 00:42:26,640
a lot of how the compilation happens,

889
00:42:26,640 --> 00:42:28,599
how the inlining happens, all that.

890
00:42:28,599 --> 00:42:31,359
That is also kind of like what helps you.

891
00:42:31,400 --> 00:42:35,959
Yes, I think it can make a difference at the very top.

892
00:42:35,959 --> 00:42:39,599
So I remember Thomas Wurtiger here specified

893
00:42:39,599 --> 00:42:42,839
lots of compiler flags and, you know,

894
00:42:42,839 --> 00:42:47,439
options to get out like the last few percents.

895
00:42:47,439 --> 00:42:50,760
I suppose it's something which you do like really at the end.

896
00:42:50,760 --> 00:42:53,479
You know, once you have sorted out all the other stuff,

897
00:42:53,479 --> 00:42:54,839
you have done all your profiling

898
00:42:54,839 --> 00:42:58,439
and you avoid all the unnecessary allocations and whatnot,

899
00:42:58,439 --> 00:43:01,599
then I guess you can get like the last little bit

900
00:43:01,599 --> 00:43:02,760
with those kinds of things.

901
00:43:02,760 --> 00:43:06,400
Trying to see how a compiler actually gets stuff.

902
00:43:06,400 --> 00:43:10,640
Yes, and also it's getting then machine-specific, right?

903
00:43:10,640 --> 00:43:12,280
So this also was very interesting.

904
00:43:12,280 --> 00:43:17,079
So Roy, at some point, so he was working on his ARM MacBook,

905
00:43:17,079 --> 00:43:20,400
like M1 MacBook, and the evaluation machine

906
00:43:20,400 --> 00:43:23,479
was an Intel AMD EPYC server.

907
00:43:23,479 --> 00:43:27,359
And now he got to a point where he did optimizations,

908
00:43:27,359 --> 00:43:30,040
so it was faster on his local laptop,

909
00:43:30,040 --> 00:43:30,880
but he submitted it.

910
00:43:30,880 --> 00:43:33,280
Then it was actually slower on the evaluation machine

911
00:43:33,280 --> 00:43:34,119
because, I don't know,

912
00:43:34,119 --> 00:43:38,479
it had different lengths of SIMD instruction sets and so on.

913
00:43:38,479 --> 00:43:40,920
So he dug out like an old Intel MacBook

914
00:43:40,920 --> 00:43:42,640
he had somewhere to, you know,

915
00:43:42,640 --> 00:43:44,760
have better odds to come up with changes,

916
00:43:44,760 --> 00:43:48,160
which also proved beneficial on the official environment.

917
00:43:48,160 --> 00:43:50,479
As I'm listening to this,

918
00:43:50,479 --> 00:43:54,560
did you thought that like disabling a garbage collector

919
00:43:54,599 --> 00:43:57,280
would be crazy for production code

920
00:43:57,280 --> 00:43:58,560
before you had this challenge?

921
00:43:58,560 --> 00:44:00,719
And now you think it's like more understandable?

922
00:44:00,719 --> 00:44:03,560
Did it change like some views when it comes to,

923
00:44:03,560 --> 00:44:07,319
because after I'm listening,

924
00:44:07,319 --> 00:44:08,800
what you are saying is like,

925
00:44:08,800 --> 00:44:10,319
yeah, if it's a short-lived task

926
00:44:10,319 --> 00:44:13,160
and you just like have the objects there not collected,

927
00:44:13,160 --> 00:44:15,199
like who does really care, right?

928
00:44:15,199 --> 00:44:17,800
So I had heard about it before.

929
00:44:17,800 --> 00:44:20,760
So I think it's actually common in like high frequency

930
00:44:20,760 --> 00:44:21,599
trading and so on.

931
00:44:21,599 --> 00:44:24,160
So what they do there is they,

932
00:44:24,680 --> 00:44:28,760
try to avoid or don't do any allocations

933
00:44:28,760 --> 00:44:30,439
in the steady state of the application.

934
00:44:30,439 --> 00:44:32,760
And then they keep it running for a day

935
00:44:32,760 --> 00:44:34,400
and it doesn't need to do any garbage collection.

936
00:44:34,400 --> 00:44:36,280
And then they, or maybe,

937
00:44:36,280 --> 00:44:39,520
just so low allocations.

938
00:44:39,520 --> 00:44:42,079
And if they start a process with enough memory,

939
00:44:42,079 --> 00:44:44,640
it is enough to keep running for an entire day.

940
00:44:44,640 --> 00:44:47,319
They would kill it off after the day and like restart it.

941
00:44:47,319 --> 00:44:49,040
So I had heard about it before.

942
00:44:49,040 --> 00:44:51,640
I personally haven't done it before,

943
00:44:51,640 --> 00:44:53,079
but yeah, I guess I would,

944
00:44:53,079 --> 00:44:56,199
in particular for CLI tools, I guess I would.

945
00:44:56,199 --> 00:44:57,640
Nothing crazy, right?

946
00:44:57,640 --> 00:44:59,640
Well, yeah, yeah, totally.

947
00:45:01,800 --> 00:45:03,839
We're on that point in our episode

948
00:45:03,839 --> 00:45:07,599
that I have to ask everybody to like and subscribe.

949
00:45:07,599 --> 00:45:09,359
Oh yes, of course, like and subscribe.

950
00:45:09,359 --> 00:45:10,560
Like and subscribe.

951
00:45:10,560 --> 00:45:12,560
We appreciate that more followers we have,

952
00:45:12,560 --> 00:45:14,520
the easier it is to make these things.

953
00:45:14,520 --> 00:45:16,280
And I should also mention

954
00:45:16,280 --> 00:45:18,400
that we are very grateful for our Patreons

955
00:45:18,400 --> 00:45:21,199
that supports us and our partners

956
00:45:21,199 --> 00:45:24,920
who are 3FS, Kaldi and Human Frog.

957
00:45:24,920 --> 00:45:28,959
These are like web or tech related companies in Slovenia

958
00:45:28,959 --> 00:45:30,560
and they support us and it means a lot.

959
00:45:30,560 --> 00:45:32,839
So thank everybody for the support

960
00:45:32,839 --> 00:45:35,839
and make it for also hosting us.

961
00:45:35,839 --> 00:45:37,479
Okay, that's a PR part.

962
00:45:37,479 --> 00:45:38,599
Right.

963
00:45:38,599 --> 00:45:39,680
Super important to be sustainable.

964
00:45:39,680 --> 00:45:40,680
Super important.

965
00:45:42,479 --> 00:45:45,800
Do you wanna talk more perhaps about these two seconds

966
00:45:45,800 --> 00:45:47,479
because otherwise I'm gonna move more

967
00:45:47,479 --> 00:45:48,920
towards a few other things.

968
00:45:49,479 --> 00:45:52,800
No, I think we got it covered mostly.

969
00:45:52,800 --> 00:45:54,280
Oh, actually there's one thing which I really like.

970
00:45:54,280 --> 00:45:56,680
This was my most favorite thing, I think.

971
00:45:56,680 --> 00:45:59,119
So in Thomas Vertigo's implementation,

972
00:45:59,119 --> 00:46:00,719
there's an interesting detail.

973
00:46:00,719 --> 00:46:04,160
So you see essentially his inner processing loop.

974
00:46:04,160 --> 00:46:05,479
He has it like duplicated.

975
00:46:05,479 --> 00:46:07,479
It's like there in the source code, like three times.

976
00:46:07,479 --> 00:46:10,520
So he has scanner objects

977
00:46:10,520 --> 00:46:12,800
which process different lines of the file.

978
00:46:12,800 --> 00:46:15,119
And he has the same loop with different scanners

979
00:46:15,119 --> 00:46:15,959
like three times.

980
00:46:15,959 --> 00:46:18,680
And so you look at his code and it's written there

981
00:46:19,439 --> 00:46:21,640
and you would say it's like sequentially executed.

982
00:46:21,640 --> 00:46:24,760
The thing is what happens, the compiler figures,

983
00:46:24,760 --> 00:46:28,280
there's no data dependency between those different chunks.

984
00:46:28,280 --> 00:46:31,000
And as CPUs have like multiple execution units,

985
00:46:31,000 --> 00:46:33,680
it actually gets executed in parallel.

986
00:46:33,680 --> 00:46:34,640
It runs concurrently.

987
00:46:34,640 --> 00:46:37,319
So you look at the code sequentially,

988
00:46:37,319 --> 00:46:39,760
but it's actually gets executed concurrently.

989
00:46:39,760 --> 00:46:41,880
So it saves time.

990
00:46:41,880 --> 00:46:45,640
And how he arrived at three, so it was like heuristically.

991
00:46:45,640 --> 00:46:48,119
So he tried it with two copies of the loop

992
00:46:48,119 --> 00:46:49,560
with four copies of the loop.

993
00:46:49,560 --> 00:46:50,959
Three was the fastest.

994
00:46:50,959 --> 00:46:52,719
So this, I had no idea about this.

995
00:46:52,719 --> 00:46:53,680
I found it super interesting.

996
00:46:53,680 --> 00:46:56,439
And of course, this also gets into this question

997
00:46:56,439 --> 00:46:57,920
like how maintainable is this code, right?

998
00:46:57,920 --> 00:47:00,880
Because imagine like the new guy comes onto the team.

999
00:47:00,880 --> 00:47:02,599
He's like, oh, there's like the same code,

1000
00:47:02,599 --> 00:47:04,000
like three times, let me clean it up.

1001
00:47:04,000 --> 00:47:05,959
I want to like refactor it, make one loop

1002
00:47:05,959 --> 00:47:07,680
and boom, your optimization is away, right?

1003
00:47:07,680 --> 00:47:10,479
So I guess you would want to put a comment there.

1004
00:47:10,479 --> 00:47:15,079
Perhaps a bit, a few words about like the top guys.

1005
00:47:15,079 --> 00:47:17,680
My understanding is that the top solution,

1006
00:47:18,400 --> 00:47:19,880
it's not written by one guy.

1007
00:47:19,880 --> 00:47:20,719
I think three-

1008
00:47:20,719 --> 00:47:21,560
They teamed up, yes, exactly.

1009
00:47:21,560 --> 00:47:22,640
Three, it's a team effort.

1010
00:47:22,640 --> 00:47:25,560
And these are guys that are actually working on GraalVM

1011
00:47:25,560 --> 00:47:28,400
with Oracle, Oracle Labs, is that correct?

1012
00:47:28,400 --> 00:47:29,239
Yeah.

1013
00:47:29,239 --> 00:47:30,920
Do you know the guys or have you-

1014
00:47:30,920 --> 00:47:33,160
Yes, I knew Thomas before we had met before.

1015
00:47:33,160 --> 00:47:34,800
They're scary a bit.

1016
00:47:34,800 --> 00:47:35,640
Say again?

1017
00:47:35,640 --> 00:47:36,479
They are scary guys.

1018
00:47:36,479 --> 00:47:37,680
Oh, I don't know.

1019
00:47:37,680 --> 00:47:39,760
I think they are nice guys.

1020
00:47:39,760 --> 00:47:41,800
And actually this was exactly also in the spirit

1021
00:47:41,800 --> 00:47:44,920
of the challenge to learn and inspire each other.

1022
00:47:44,920 --> 00:47:49,199
So at some point Thomas saw an interesting optimization

1023
00:47:49,199 --> 00:47:52,319
in the solution from Merikitty.

1024
00:47:52,319 --> 00:47:56,119
I forgot his actual name, but he goes as Merikitty online.

1025
00:47:56,119 --> 00:47:57,400
So he had a very nice trick.

1026
00:47:57,400 --> 00:47:59,000
And so Thomas incorporated that.

1027
00:47:59,000 --> 00:48:00,479
And then they said, okay, let's team up

1028
00:48:00,479 --> 00:48:04,239
and make it official, which then proved to be a problem

1029
00:48:04,239 --> 00:48:06,839
for my little certificates at the end,

1030
00:48:06,839 --> 00:48:10,439
because I gave like a PDF to everybody with their time.

1031
00:48:10,439 --> 00:48:13,599
So I learned how to do mail merge

1032
00:48:13,599 --> 00:48:17,520
and create individual PDFs for 160 people.

1033
00:48:17,520 --> 00:48:19,359
Yeah, but they're listed on one page.

1034
00:48:19,359 --> 00:48:20,199
Okay.

1035
00:48:20,199 --> 00:48:21,040
Yes, exactly.

1036
00:48:21,040 --> 00:48:23,599
And the problem was, so they had like three names.

1037
00:48:23,599 --> 00:48:25,319
So for them, my template wouldn't fit.

1038
00:48:25,319 --> 00:48:28,520
And I had like to do it like a bespoke one just for them.

1039
00:48:28,520 --> 00:48:30,040
Do you think that like these,

1040
00:48:31,000 --> 00:48:33,160
the side effects of these challenge,

1041
00:48:33,160 --> 00:48:38,160
like we did some challenge two years ago, much smaller,

1042
00:48:39,079 --> 00:48:41,719
but, and the challenge that was,

1043
00:48:41,719 --> 00:48:44,959
I'm gonna post link as below as well.

1044
00:48:44,959 --> 00:48:49,959
But that challenge was so intrigued to some people.

1045
00:48:50,119 --> 00:48:52,479
We didn't limit languages.

1046
00:48:52,479 --> 00:48:54,000
So one of the guys decided

1047
00:48:54,000 --> 00:48:55,760
to write his own programming language.

1048
00:48:55,760 --> 00:48:56,599
Oh wow, okay.

1049
00:48:56,599 --> 00:48:59,119
So yeah, Janko, if you're listening, cheers.

1050
00:48:59,119 --> 00:49:01,880
And, but the side effect was he learned

1051
00:49:01,880 --> 00:49:03,920
that he can make his language better

1052
00:49:03,920 --> 00:49:05,920
because of like, it's trying to do it.

1053
00:49:06,239 --> 00:49:07,479
Trying to understand these challenges,

1054
00:49:07,479 --> 00:49:11,000
kind of like solid problems in his implementation.

1055
00:49:11,000 --> 00:49:11,839
Like he improved like,

1056
00:49:11,839 --> 00:49:13,760
do you think that something similar might happen

1057
00:49:13,760 --> 00:49:16,439
from this challenge or lessons like that?

1058
00:49:16,439 --> 00:49:17,280
Right.

1059
00:49:17,280 --> 00:49:18,520
So I don't think anybody invented

1060
00:49:18,520 --> 00:49:19,959
their own programming language,

1061
00:49:19,959 --> 00:49:22,319
but definitely people told me many times, yes,

1062
00:49:22,319 --> 00:49:26,959
that they learn so much about Java, learn new things.

1063
00:49:26,959 --> 00:49:30,959
And also it's definitely helped to,

1064
00:49:30,959 --> 00:49:33,560
you know, to debunk this,

1065
00:49:33,839 --> 00:49:36,640
you know, to debunk this misconception,

1066
00:49:36,640 --> 00:49:37,680
like Java is slow.

1067
00:49:37,680 --> 00:49:40,479
So many people made that realization.

1068
00:49:40,479 --> 00:49:42,880
And also for other ecosystems, right?

1069
00:49:42,880 --> 00:49:46,040
So people may be not as familiar with Java as we are.

1070
00:49:46,040 --> 00:49:48,400
They also learned, oh, actually there is something going on.

1071
00:49:48,400 --> 00:49:49,959
It has like all those new APIs.

1072
00:49:49,959 --> 00:49:52,560
It's really optimized, really competitive.

1073
00:49:52,560 --> 00:49:54,800
So I think people took a lot from it.

1074
00:49:54,800 --> 00:49:55,640
Yes.

1075
00:49:55,640 --> 00:49:57,160
Is there any traction from academia?

1076
00:49:57,160 --> 00:49:58,640
I know that might sound silly,

1077
00:49:58,640 --> 00:50:00,160
but we would help you like.

1078
00:50:00,000 --> 00:50:06,960
I have not seen any academic paper yet, maybe, yeah.

1079
00:50:06,960 --> 00:50:07,960
To come.

1080
00:50:07,960 --> 00:50:08,960
Yeah.

1081
00:50:08,960 --> 00:50:14,360
Did you also, um, you made the decision this is going to be a Java challenge and it's for

1082
00:50:14,360 --> 00:50:21,440
practical reasons, I guess, imagine, but if you go to 1BRC.dev, it's a webpage, I don't

1083
00:50:21,440 --> 00:50:22,559
think you created it.

1084
00:50:22,559 --> 00:50:23,559
I know, I did not.

1085
00:50:23,559 --> 00:50:24,559
It's very interesting.

1086
00:50:24,559 --> 00:50:29,840
But that one also has a collection of links to other programming languages.

1087
00:50:29,840 --> 00:50:34,320
So you can see the solution in C, Python, all these different languages.

1088
00:50:34,320 --> 00:50:36,360
Did you have a peek into these solutions as well?

1089
00:50:36,360 --> 00:50:37,360
Yes, briefly.

1090
00:50:37,360 --> 00:50:40,000
So I mean, what we do have, so I mean, why was it Java only?

1091
00:50:40,000 --> 00:50:43,959
So yes, first of all, for practical reasons, I just felt like, you know, that's what I'm

1092
00:50:43,959 --> 00:50:44,959
most familiar with.

1093
00:50:44,959 --> 00:50:51,119
And if I need to learn how to install like Rust tool chains or how to compile with C

1094
00:50:51,119 --> 00:50:54,000
or whatever, it would just take, you know, so much more time.

1095
00:50:54,000 --> 00:50:55,480
And I wanted to limit it a little bit.

1096
00:50:55,480 --> 00:50:56,919
So that was the one reason.

1097
00:50:56,919 --> 00:51:00,919
The other reason is, well, I wanted to help and promote Java also, and that's why I limited

1098
00:51:00,919 --> 00:51:02,680
to Java.

1099
00:51:02,680 --> 00:51:07,559
But then we actually, so all is, all this happens in a GitHub repo, like, you know,

1100
00:51:07,559 --> 00:51:10,959
my name, Gunnar Molling, and then 1BRC, that's the repo.

1101
00:51:10,959 --> 00:51:16,720
And we have a GitHub discussion there, which is called show and tell.

1102
00:51:16,720 --> 00:51:22,279
And people are very much invited to share their links to their non-Java implementations.

1103
00:51:22,279 --> 00:51:24,480
And this also got really huge.

1104
00:51:24,480 --> 00:51:29,400
So there's like, I don't know, 60, 70 threads of discussions there with other implementations

1105
00:51:29,400 --> 00:51:36,040
like Rust and .NET and C and even COBOL and, you know, all kinds of languages.

1106
00:51:36,040 --> 00:51:38,080
Some of them I hadn't heard about even before.

1107
00:51:38,080 --> 00:51:44,519
Then other tools like Org, you know, on the command line, but then also databases, Postgres,

1108
00:51:44,519 --> 00:51:46,279
Apache Pino, Snowflake.

1109
00:51:46,279 --> 00:51:50,160
So people, you know, did it with all kinds of tools and languages.

1110
00:51:50,160 --> 00:51:51,599
So I kept an eye on it.

1111
00:51:51,599 --> 00:51:57,040
I enjoyed reading the blog posts, but I couldn't run them on my environment just to, because

1112
00:51:57,040 --> 00:52:00,599
of the time reasons.

1113
00:52:00,599 --> 00:52:04,480
I guess we were more like at the end of these kind of things.

1114
00:52:04,480 --> 00:52:07,279
We will go swimming later on.

1115
00:52:07,279 --> 00:52:08,880
Oh, nice.

1116
00:52:08,880 --> 00:52:09,880
Okay.

1117
00:52:09,880 --> 00:52:14,559
I guess before we talk more about price.

1118
00:52:14,559 --> 00:52:19,639
So I guess the price was, there was a price, at least that's my understanding of Twitter

1119
00:52:19,639 --> 00:52:20,639
threads or whatever.

1120
00:52:20,639 --> 00:52:22,320
The most important thing in life.

1121
00:52:22,320 --> 00:52:23,559
The most important thing in life.

1122
00:52:23,559 --> 00:52:24,559
Yes.

1123
00:52:24,559 --> 00:52:25,559
Yes.

1124
00:52:25,559 --> 00:52:28,080
So obviously the price is, you're the top dog in the industry, I guess.

1125
00:52:28,080 --> 00:52:29,080
Right.

1126
00:52:29,080 --> 00:52:32,479
So the price is learning something new and being part of it.

1127
00:52:32,479 --> 00:52:33,479
But yes.

1128
00:52:33,479 --> 00:52:37,720
So initially, I mean, so this was like really, you know, my own private effort initially

1129
00:52:37,720 --> 00:52:38,720
at least.

1130
00:52:38,720 --> 00:52:42,559
And so I said, okay, I will pay for a t-shirt for the winner.

1131
00:52:42,559 --> 00:52:44,839
I will pay for a t-shirt out of my own pocket.

1132
00:52:44,839 --> 00:52:46,800
That's what I decided to do.

1133
00:52:46,800 --> 00:52:51,479
And then, well, it really took off and I felt, okay, maybe we want to do something more.

1134
00:52:51,479 --> 00:52:57,479
And then I spoke to my employer Decodable and they were happy not only to fund the evaluation

1135
00:52:57,479 --> 00:53:03,759
machine, but also I have a company credit card, so I just can pay for some prices.

1136
00:53:03,759 --> 00:53:11,279
So what I did in the end is I did t-shirts for the top three and coffee mugs for the

1137
00:53:11,279 --> 00:53:12,279
top 20.

1138
00:53:13,000 --> 00:53:20,320
And then I sent to like South Korea, Taiwan, Croatia, actually I was in Zagreb and U.S.

1139
00:53:20,320 --> 00:53:22,199
and so like Brazil, like all over the world.

1140
00:53:22,199 --> 00:53:26,240
So this was my biggest challenge, like shipping this stuff to people all over the world.

1141
00:53:26,240 --> 00:53:27,240
Beautiful.

1142
00:53:27,240 --> 00:53:32,600
So at this point, thanks for Decodable for actually supporting you on this.

1143
00:53:32,600 --> 00:53:37,240
I guess if people have ideas for next year.

1144
00:53:37,240 --> 00:53:38,240
Absolutely.

1145
00:53:38,240 --> 00:53:39,240
Yes.

1146
00:53:39,240 --> 00:53:40,240
They should contact you on Twitter.

1147
00:53:40,240 --> 00:53:41,240
Right.

1148
00:53:41,240 --> 00:53:46,440
They should contact me on Twitter or send me an email to Gunnar at decodable.co.

1149
00:53:46,440 --> 00:53:48,399
People asked what would be the challenge next year?

1150
00:53:48,399 --> 00:53:52,279
There was one guy who said next year, next January, I will take a week off.

1151
00:53:52,279 --> 00:53:55,399
So I have the entire time to focus on my implementation.

1152
00:53:55,399 --> 00:53:57,639
Let's see whether we actually want to do it.

1153
00:53:57,639 --> 00:54:02,160
So I'm still recovering from this year, but I think, yeah, by next January, if there's

1154
00:54:02,160 --> 00:54:05,720
a good idea, as we mentioned, you know, it needs to have the right balance between like

1155
00:54:05,720 --> 00:54:09,240
easy to explain and providing lots of potential.

1156
00:54:09,240 --> 00:54:13,679
If you have that, if a community comes together, if it's automated, because frankly speaking,

1157
00:54:13,679 --> 00:54:17,720
I don't want to run all this stuff manually again on this machine, so it would have to

1158
00:54:17,720 --> 00:54:22,239
be automated with GitHub Actions, I suppose, like people could like really self-certify,

1159
00:54:22,239 --> 00:54:25,459
you know, and it would be like a GitHub Actions runner on that machine.

1160
00:54:25,459 --> 00:54:29,920
If we have all that and people help doing that, I would definitely be up for doing it

1161
00:54:29,920 --> 00:54:31,720
again.

1162
00:54:31,720 --> 00:54:34,119
You have any more questions, Andras, otherwise I'm going to slowly...

1163
00:54:34,119 --> 00:54:36,239
No, I think that was an awesome conversation.

1164
00:54:36,239 --> 00:54:37,600
Very, very nice.

1165
00:54:37,679 --> 00:54:44,440
I would like to like perhaps wrap up with like last kind of a big question or what are

1166
00:54:44,440 --> 00:54:48,959
the lessons that are not technical that you got out of this?

1167
00:54:48,959 --> 00:54:49,959
Right.

1168
00:54:49,959 --> 00:54:56,959
First of all, yeah, never underestimate how much people would do to win this kind of thing.

1169
00:54:56,959 --> 00:55:01,920
So this definitely, you know, I did not expect this, like people would spend an entire month

1170
00:55:01,920 --> 00:55:04,239
on doing that.

1171
00:55:04,320 --> 00:55:08,200
And then, yes, people will take advantage of whatever they can, so they will optimize

1172
00:55:08,200 --> 00:55:14,640
for the key set, they will, you know, bend all the rules, there was stuff which we didn't

1173
00:55:14,640 --> 00:55:18,440
even talk about, like unmapping the file, so they will do all kinds of stuff.

1174
00:55:18,440 --> 00:55:22,760
So I did, you know, did not expect it, but still, you know, it's all good and fun.

1175
00:55:22,760 --> 00:55:27,239
And then of course, yes, I mean, I guess I was hoping to see it, but it also definitely

1176
00:55:27,239 --> 00:55:32,679
happened like how the community comes together, not only to participate and take something

1177
00:55:32,679 --> 00:55:36,399
out of it, but also to help and organize it and help and run it.

1178
00:55:36,399 --> 00:55:40,320
And this was just so great to see, because at some point I was just overwhelmed.

1179
00:55:40,320 --> 00:55:45,679
And I felt, oh man, it's so much, I spent like 12 hours a day trying to be on top of

1180
00:55:45,679 --> 00:55:51,119
stuff and people helped and, you know, this only made it possible.

1181
00:55:51,119 --> 00:55:56,040
And I guess the last thing is, yeah, I mean, it was a bit of a viral thing, right, it really

1182
00:55:56,040 --> 00:55:57,040
blew up.

1183
00:55:57,239 --> 00:56:03,359
What I also found very interesting, so like how you lose control over the narrative and

1184
00:56:03,359 --> 00:56:04,920
how, what happens, right.

1185
00:56:04,920 --> 00:56:08,920
Because people will take it and make something out of it, like they want.

1186
00:56:08,920 --> 00:56:12,920
And you know, at some point there was like a bit of a fight between like Java and other

1187
00:56:12,920 --> 00:56:16,320
languages and I didn't really want it to be like that.

1188
00:56:16,320 --> 00:56:18,959
But at some point, yeah, you're not like fully in control.

1189
00:56:18,959 --> 00:56:19,959
You're just like participating.

1190
00:56:19,959 --> 00:56:30,239
It feels like a modern, big open source community kind of a thing, where a lot of problems kind

1191
00:56:30,239 --> 00:56:31,239
of here.

1192
00:56:31,239 --> 00:56:32,239
Right.

1193
00:56:32,239 --> 00:56:33,239
And it can be a bit scary, right?

1194
00:56:33,239 --> 00:56:34,239
It can be a bit scary.

1195
00:56:34,239 --> 00:56:40,239
Because it just, stuff happens and you try to navigate it as good as you can.

1196
00:56:40,239 --> 00:56:43,200
So this also was definitely very interesting to observe.

1197
00:56:43,200 --> 00:56:44,200
Okay.

1198
00:56:44,200 --> 00:56:46,920
I guess, any last words from you András?

1199
00:56:46,920 --> 00:56:47,920
Yeah.

1200
00:56:47,920 --> 00:56:53,119
I would invite our community to join us on Discord and share the attempts or the solutions

1201
00:56:53,119 --> 00:56:54,119
that would be awesome.

1202
00:56:54,119 --> 00:56:57,000
Like to see what we can come up with.

1203
00:56:57,000 --> 00:56:58,000
Yeah.

1204
00:56:58,000 --> 00:56:59,000
Yeah.

1205
00:56:59,000 --> 00:57:00,000
Definitely.

1206
00:57:00,000 --> 00:57:03,959
From my side, I invite you to follow Gunnar on Twitter.

1207
00:57:03,959 --> 00:57:08,519
It's a stream of very useful information also from Flink and DCDN.

1208
00:57:08,519 --> 00:57:10,640
So yeah, you should follow him.

1209
00:57:10,640 --> 00:57:13,559
And thank you from bottom of my heart for taking the time and taking us through this

1210
00:57:13,559 --> 00:57:14,559
challenge.

1211
00:57:14,559 --> 00:57:16,799
And I will be really looking forward to what you'll come up next year.

1212
00:57:16,799 --> 00:57:17,799
Okay, awesome.

1213
00:57:17,799 --> 00:57:18,799
Thank you so much, Remy.

1214
00:57:18,799 --> 00:57:19,799
This was great.

1215
00:57:19,799 --> 00:57:20,799
I really enjoyed the conversation.

1216
00:57:20,799 --> 00:57:21,799
And this was really fun.

1217
00:57:21,799 --> 00:57:22,799
Thank you.

1218
00:57:22,799 --> 00:57:23,799
Thank you.

1219
00:57:23,799 --> 00:57:24,799
Bye.

1220
00:57:24,799 --> 00:57:25,799
That's it.

1221
00:57:25,799 --> 00:57:26,799
Have a nice day.

1222
00:57:26,799 --> 00:57:26,799